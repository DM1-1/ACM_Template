# 目录

## [字符串](#STRING)





## [数据结构](#DS)







## [图论](#Graph)






## [动态规划](#DP)





## [数论](#Numbertheory)







## [博弈](#game)







## [杂项](#Other)







# 模板

## <a id="STRING">字符串</a>

### 双哈希

```cpp
typedef pair<int, int> hashv;
const ll mod1 = 1000000007;
const ll mod2 = 1000000009;

const int N = ?;
hashv pw[N]; //预处理幂次

hashv operator+ (hashv a, hashv b)
{
    int c1 = a.first + b.first;
    int c2 = a.second + b.second;
    if(c1 >= mod1)
        c1 -= mod1;
    if(c2 >= mod2)
        c2 -= mod2;
    return make_pair(c1, c2);
}
hashv operator- (hashv a, hashv b)
{
    int c1 = a.first - b.first;
    int c2 = a.second - b.second;
    if(c1 < 0)
        c1 += mod1;
    if(c2 < 0)
        c2 += mod2;
    return make_pair(c1, c2);
}
hashv operator* (hashv a, hashv b)
{
    return make_pair(1ll * a.first * b.first % mod1, 1ll * a.second * b.second % mod2);
}

void init() //记得调用
{
    hashv base = make_pair(13331, 23333); 
    pw[0] = make_pair(1, 1);   
}

hashv get(int l, int r) //反串就swap(l, r)
{
    return h[r] - h[l - 1] * pw[r - l + 1];
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)
        pw[i] = pw[i - 1] * base;

    for(int i = 1; i <= n; i ++)
        h[i] = h[i - 1] * base + make_pair(s[i], s[i]);
}
```









## <a id="DS">数据结构</a>

###  单调栈

```

```



### 单调队列

```

```



### 种类并查集

```


```





### 树状数组

```cpp
struct BIT {
    ll c[N];
    void add(int x, int val) {
        for (int i = x; i < N; i += i & -i) {
            c[i] += val;
        }
    }
    ll ask(int x) {
        ll ans = 0;
        for (int i = x; i; i -= i & -i) {
            ans += c[i];
        }
        return ans;
    }
};
```



### 高维树状数组

```cpp
struct BIT {
    ll bit[N][N];
    void add(int x, int y, ll d) {
        for(int i = x; i <= n; i += lowbit(i))
            for(int j = y; j <= m; j += lowbit(j))
                bit[i][j] += d;
    };
    ll query(int x, int y) {
        ll res = 0;
        for(int i = x; i; i -= lowbit(i))
            for(int j = y; j; j -= lowbit(j))
                res += bit[i][j];
        return res;
    }
};
BIT a;
```





### 线段树

基础线段树（加法）

```cpp
struct Seg_Tree {
    struct node {
        int l, r;
        ll s;
        
    } seg[N * 4];
    void pushup(int k)
    {

    }
    void set_tag(int k, int l, int r)
    {

    }
    void pushdown(int k)
    {   

    }
    void build(int k, int l, int r) //记得调用
    {
        seg[k] = {l, r};
        if(l == r) {
            seg[k].s = ?;
            seg[k].lazy = ?;
            ?
            return;
        }
        int mid = (l + r) >> 1;
        build(k << 1, l, mid);
        build(k << 1 | 1, mid + 1, r);
        pushup(k);
    }
    void interval_modify(int k, int ql, int qr, ll v) //区间修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
        {
            set_tag(k, ); //更新
            return;
        }
        pushdown(k);
        int mid = (l + r) >> 1;
        if(ql <= mid)
            modify(k << 1, l, mid, v);
        if(mid < qr)
            modify(k << 1 | 1, mid + 1, r, v);
        pushup(k);
    }    
    ll interval_query(int k, int ql, int qr)
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
            return seg[k].s;
        pushdown(k);
        int mid = (l + r) >> 1;
        ll res = 0;
        if(ql <= mid)
            res += query(k << 1, ql, qr), res %= mod;
        if(mid < qr)
            res += query(k << 1 | 1, ql, qr), res %= mod;
        return res;
    }
    void point_modify(int k, int pos, ll v) //单点修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
        {
            //
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            point_modify(k << 1, pos, v);
        else
            point_modify(k << 1 | 1, pos, v);
        pushup(k);
    }
    ll point_query(int k, int pos)
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
            return seg[k].s;
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            return point_modify(k << 1, pos);
        else
            return point_modify(k << 1 | 1, pos);
        pushup(k);
    }
};
Seg_Tree T1;

int main()
{
    //调用
    T1.build(1, 1, n);  
    T1.interval_modify(1, 2, 4, 5);
}
```

维护和，平方和，立方和（加乘）

```cpp
const int N = 100005;
const int mod = 10007;

int n, m;
struct node {
    int tag_add, tag_mul;
    int sum1, sum2, sum3;
} seg[N * 4];
int a[N];

void update(int k, int len, int add, int mul)
{
    seg[k].tag_mul = seg[k].tag_mul * mul % mod;
    seg[k].tag_add = seg[k].tag_add * mul % mod;
    seg[k].tag_add = ((seg[k].tag_add + add) % mod + mod) % mod;
    if(mul != 1)
    {
        seg[k].sum1 = 1ll * seg[k].sum1 * mul % mod;
        seg[k].sum2 = 1ll * seg[k].sum2 * mul % mod * mul % mod;
        seg[k].sum3 = 1ll * seg[k].sum3 * mul % mod * mul % mod * mul % mod;
    }
    if(add != 0)
    {
        int add2 = add * add % mod, add3 = add2 * add % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum2 % mod * add % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum1 % mod * add2 % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 1ll * len * add3 % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 2ll * seg[k].sum1 % mod * add % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 1ll * len * add2 % mod) + mod) % mod;
        seg[k].sum1 = ((seg[k].sum1 + 1ll * len * add % mod) + mod) % mod;
    }
}

void pushup(int k)
{
    seg[k].sum1 = (seg[k << 1].sum1 + seg[k << 1 | 1].sum1) % mod;
    seg[k].sum2 = (seg[k << 1].sum2 + seg[k << 1 | 1].sum2) % mod;
    seg[k].sum3 = (seg[k << 1].sum3 + seg[k << 1 | 1].sum3) % mod;
}

void build(int k, int l, int r) //记得调用
{
    seg[k].tag_add = 0;
    seg[k].tag_mul = 1;
    if(l == r) {
        seg[k].sum1 = a[l];
        seg[k].sum2 = seg[k].sum1 * a[l] % mod;
        seg[k].sum3 = seg[k].sum2 * a[l] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    pushup(k);
}

void pushdown(int k, int len)
{
    update(k << 1, (len - (len >> 1)), seg[k].tag_add, seg[k].tag_mul);
    update(k << 1 | 1, len >> 1, seg[k].tag_add, seg[k].tag_mul);
    seg[k].tag_add = 0, seg[k].tag_mul = 1;
}

void modify(int k, int l, int r, int ql, int qr, int add, int mul)
{
    if(ql <= l && r <= qr)
    {
        update(k, r - l + 1, add, mul);
        return;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    if(ql <= mid)
        modify(k << 1, l, mid, ql, qr, add, mul);
    if(mid < qr)
        modify(k << 1 | 1, mid + 1, r, ql, qr, add, mul);
    pushup(k);
}

int query(int k, int l, int r, int ql, int qr, int d)
{
    if(ql <= l && r <= qr)
    {
        if(d == 1)  return seg[k].sum1;
        if(d == 2)  return seg[k].sum2;
        if(d == 3)  return seg[k].sum3;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    int res = 0;
    if(ql <= mid)
        res += query(k << 1, l, mid, ql, qr, d), res %= mod;
    if(mid < qr)
        res += query(k << 1 | 1, mid + 1, r, ql, qr, d), res %= mod;
    pushup(k);
    return res;
}

void init()
{
    for(int i = 1; i <= n; i ++)    
        a[i] = 0;
}

int main()
{
    while(scanf("%d%d", &n, &m))
    {
        if(!n && !m)
            break;
        init();
        build(1, 1, n);

        while(m --)
        {
            int op, l, r, v;
            scanf("%d%d%d%d", &op, &l, &r, &v);
            if(op == 1)
                modify(1, 1, n, l, r, v, 1);
            else if(op == 2)
                modify(1, 1, n, l, r, 0, v);
            else if(op == 3)
                modify(1, 1, n, l, r, v, 0);
            else 
                printf("%d\n", query(1, 1, n, l, r, v));
        }
    }
    return 0;
}
```



### 李超线段树

```txt
维护两个操作
1、插入一条直线、直线覆盖长度为整个区间
2、查询现在所有直线中当x = x'时，y'的最大和最小值
```

```c++
//线段长度全部覆盖[1, n]
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define ll long long
#define db long double
#define pii pair<ll,ll>
#define lowbit(x) x&-x
#define u64 unsigned long long
#define MAX_INF 0x3f
#define MAX_INF_VAL 0x3f3f3f3f
#define MAX_INF_VAL_LL 0x3f3f3f3f3f3f3f3f
using namespace std;
const int mod = 1e9 + 7;
const int N = 1e6 + 100;
inline ll read() 
{
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node
{
    ll k, b;  //斜率k和常数b
}seg[N * 4];
int n, m;
ll cal (node &f, int x)  //函数值
{
    return f.k * x + f.b;
}
void modify(int k, int l, int r, int ql, int qr, node w)
{
    int mid = l + r >> 1;
    if (ql == l && r == qr)
    {
        if (seg[k].k == MAX_INF_VAL_LL)
        {
            seg[k] = w;
            return;
        }
        ll yl_ori = cal(seg[k], ql);
        ll yr_ori = cal(seg[k], qr);
        ll yl_new = cal(w, ql);
        ll yr_new = cal(w, qr);
        if (yl_ori >= yl_new && yr_ori >= yr_new) return;
        else if (yl_ori <= yl_new && yr_ori <= yr_new)
        {
            seg[k] = w;
        }
        else
        {
            ll ymid_ori = cal(seg[k], mid);
            ll ymid_new = cal(w, mid);
            if (ymid_new > ymid_ori) //中间点谁高谁覆盖的面积多
            {
                if (yl_new <= yl_ori)
                    modify (k<<1, l, mid, ql, mid, seg[k]);
                else
                    modify (k<<1|1, mid + 1, r, mid + 1, qr, seg[k]);
                seg[k] = w;
            }
            else 
            {
                if (yl_new <= yl_ori)
                    modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
                else 
                    modify(k<<1, l, mid, ql, mid, w);
            }
        }
    }
}
ll query(int k, int l, int r, int x)
{
    ll res;
    if (seg[k].k == MAX_INF_VAL_LL) res = -MAX_INF_VAL_LL;
    else res = cal(seg[k], x);
    if (l == r) return res;
    int mid = l + r >> 1;
    if (x <= mid) 
        res = max(res, query(k<<1, l, mid, x));
    else 
        res = max(res, query(k<<1|1, mid+1, r, x));
    return res;
}
int main()
{
    // std::ios::sync_with_stdio(false);
    // cin.tie(NULL);cout.tie(NULL);
    scanf("%d%d",&n, &m);
    memset(seg, MAX_INF, sizeof(seg));
    int opt, x, y;
    while(m--)
    {
        scanf("%d%d", &opt, &x);
        if (opt == 0) 
        {
            scanf("%d",&y);
            modify(1, 1, n, 1, n, {x, y});
        }
        else 
        {
            printf("%lld\n", query(1, 1, n, x)) ;
        }
    }
}
```



```txt
维护两个操作
1、插入一条线段（不覆盖整个区间了）
2、给定一个x' 求y'的最大值
```

```c++
//分区间
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define ll long long
#define db long double
#define pii pair<double,ll>
#define lowbit(x) x&-x
#define u64 unsigned long long
#define MAX_INF 0x3f
#define MAX_INF_VAL 0x3f3f3f3f
#define MAX_INF_VAL_LL 0x3f3f3f3f3f3f3f3f
using namespace std;
const int mod = 39989;
const int N = 39989 + 100;
inline ll read() 
{
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node
{
    double k, b;
    int id;
}seg[N * 4];

struct line
{
    double k, b;
    int id;
}l[100005];
int n, m, cnt;
double cal (node &f, int x)
{
    return f.k * x + f.b;
}
void modify(int k, int l, int r, int ql, int qr, node w)
{
    int mid = l + r >> 1;
    if (ql == l && r == qr)
    {
        if (seg[k].id == 0)
        {
            seg[k] = w;
            return;
        }
        double yl_ori = cal(seg[k], ql);
        double yr_ori = cal(seg[k], qr);
        double yl_new = cal(w, ql);
        double yr_new = cal(w, qr);
        if (yl_ori >= yl_new && yr_ori >= yr_new) return;
        else if (yl_ori <= yl_new && yr_ori <= yr_new)
        {
            seg[k] = w;
        }
        else
        {
            double ymid_ori = cal(seg[k], mid);
            double ymid_new = cal(w, mid);
            if (ymid_new > ymid_ori) //中间点谁高谁覆盖的面积多
            {
                if (yl_new <= yl_ori)
                    modify (k<<1, l, mid, ql, mid, seg[k]);
                else
                    modify (k<<1|1, mid + 1, r, mid + 1, qr, seg[k]);
                seg[k] = w;
            }
            else 
            {
                if (yl_new <= yl_ori)
                    modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
                else 
                    modify(k<<1, l, mid, ql, mid, w);
            }
        }
        return;
    }
    if (qr <= mid) modify(k<<1, l, mid, ql, qr, w);
    else if (ql > mid) modify(k<<1|1, mid + 1, r, ql, qr, w);
    else modify(k<<1, l, mid, ql, mid, w), modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
}

pii find(pii x, pii y)
{
    if (x.first > y.first) return x;
    else if (x.first < y.first) return y;
    else
    {
        if (x.second < y.second) return x;
        else return y;
    }
}
pii query(int k, int l, int r, int x)
{
    pii res;
    if (seg[k].id == 0) res = {-1e18, 0};
    else res = {cal(seg[k], x), seg[k].id};
    if (l == r) return res;
    int mid = l + r >> 1;
    if (x <= mid) 
        res = find(res, query(k<<1, l, mid, x));
    else 
        res = find(res, query(k<<1|1, mid+1, r, x));
    return res;
}
ll ans = 0;
int main()
{
    // std::ios::sync_with_stdio(false);
    // cin.tie(NULL);cout.tie(NULL);
    scanf("%d",&m);
    int opt, x, y, xx, yy;
    while(m--)
    {
        scanf("%d", &opt);
        if (opt == 0) 
        {
            scanf("%d",&x);
            x = (x + ans - 1)%39989+1;
            ans = query(1, 1, mod, x).second;
            printf("%lld\n", ans);
        }
        else 
        {
            scanf("%d%d%d%d",&x, &y, &xx, &yy);
            x = (x + ans - 1) % mod + 1;    //这一块是因为题目强制在线
            y = (y + ans - 1) % 1000000000 + 1;
            xx = (xx + ans - 1) % mod + 1;
            yy = (yy + ans - 1) % 1000000000 + 1;
            if (x > xx) swap(x, xx), swap(y, yy);
            double k, b;
            if (x == xx) k = 0, b = max(y, yy);
            else k = (1.0 * (y - yy)) / (x - xx), b = y - (1.0 * (y - yy)) / (x - xx) * x;
            modify(1, 1, mod, x, xx, {k, b, ++cnt});
        }
    }
}
```



### Treap

```
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1. 插入数值 x。
2. 删除数值 x (若有多个相同的数，应只删除一个)。
3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4. 查询排名为 x 的数值。
5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。
```

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100005, inf = 0x3f3f3f3f;

struct node {
    int l, r;
    int key, val;
    int cnt, sz;
} tr[N];

int rt, idx = 0;

void pushup(int p)
{
    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;
}

int get_node(int key)
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].sz = 1;
    return idx;
}

void build()
{
    get_node(-inf);
    get_node(inf);
    //添加两个哨兵防止越界
    rt = 1;
    tr[1].r = 2;
    pushup(rt);
}

void rrotate(int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r);
    pushup(p);
}

void lrotate(int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l);
    pushup(p);
}

void insert(int &p, int key)
{
    if(!p)  p = get_node(key);
    else if(tr[p].key == key)   tr[p].cnt ++;
    else if(tr[p].key > key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val > tr[p].val)
            rrotate(p);
    }
    else if(tr[p].key < key)
    {
        insert(tr[p].r, key);
        if(tr[tr[p].r].val > tr[p].val)
            lrotate(p);
    }
    pushup(p);
}

void remove(int &p, int key)
{
    if(!p)  return;
    if(tr[p].key == key) 
    {
        if(tr[p].cnt > 1)
            tr[p].cnt --;
        else if(tr[p].l || tr[p].r) //非叶子
        {
            if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                rrotate(p);
                remove(tr[p].r, key);
            }
            else
            {
                lrotate(p);
                remove(tr[p].l, key);
            }
        }
        else
            p = 0;
    }
    else if(tr[p].key > key)
        remove(tr[p].l, key);
    else 
        remove(tr[p].r, key);
    pushup(p);
}

int query_rank_by_key(int p, int key) //该数值排第几
{
    if(!p)  return 0; //查询无效
    if(tr[p].key == key)
        return tr[tr[p].l].sz + 1;
    else if(tr[p].key > key)
        return query_rank_by_key(tr[p].l, key);
    else
        return tr[tr[p].l].sz + tr[p].cnt + query_rank_by_key(tr[p].r, key);
}

int query_key_by_rank (int p, int rk) //求第rk个数的数值
{
    if(!p)  return inf; //查无此人
    if(tr[tr[p].l].sz >= rk)    
        return query_key_by_rank(tr[p].l, rk);
    else if(tr[tr[p].l].sz + tr[p].cnt >= rk)
        return tr[p].key;
    else 
        return query_key_by_rank(tr[p].r, rk - tr[tr[p].l].sz - tr[p].cnt);
}   

int get_prev(int p, int key) //严格小于key的最大数
{
    if(!p)  return -inf;
    if(tr[p].key >= key)
        return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key) //严格大于key的最小数
{
    if(!p)  return inf;
    if(tr[p].key <= key)   
        return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();
    int n;
    scanf("%d", &n);
    while(n --)
    {
        int opt, x;
        scanf("%d%d", &opt, &x);
        if(opt == 1)
            insert(rt, x);
        else if(opt == 2)
            remove(rt, x);
        else if(opt == 3)
            printf("%d\n", query_rank_by_key(rt, x) - 1); //因为加入了两个哨兵 所以需要微调
        else if(opt == 4)
            printf("%d\n", query_key_by_rank(rt, x + 1)); //因为加入了两个哨兵 所以需要微调
        else if(opt == 5)
            printf("%d\n", get_prev(rt, x));
        else 
            printf("%d\n", get_next(rt, x));
    }
}
```





### Splay

```

```





### 笛卡尔树

```

```





### 主席树

```

```





## <a id="Graph">图论</a>




## <a id="DP">动态规划</a>





## <a id="Numbertheory">数论</a> 

### 普通操作

```c++
ll gcd(ll a, ll b)  //gcd
{
    return __gcd(a, b);
}

ll lcm(ll a, ll b)  //lcm
{
    return a / gcd(a, b) * b;
}

ll mul(ll a, ll b)  //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

ll ksm(ll a, ll b)  //快速幂
{
    ll res = 1;
    while(b)
    {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll extend_gcd(ll a, ll b, ll &x, ll &y) //返回d = gcd(a, b); 并返回 ax + by = d的特解x, y
{
    if (b == 0) {x = 1; y = 0; return a;}
    ll d = extend_gcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```



### 矩阵快速幂

```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e2 + 10;
// const int mod = 1e9 + 7;
ll k, mod;
int sz;
struct mat
{
    
    ll m[N][N];
    mat() {memset(m, 0, sizeof(m));}
    void clear() {memset(m, 0, sizeof(m));}
    mat operator - (const mat& T) const 
    {
        mat res;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j)
            {
                res.m[i][j] = ((m[i][j] - T.m[i][j]) % mod + mod) % mod;
            }
        }

        return res;
    }

    mat operator + (const mat& T) const
    {
        mat res;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j)
            {
                res.m[i][j] = (m[i][j] + T.m[i][j]) % mod;
            }
        }

        return res;
    }

    mat operator * (const mat& T) const
    {
        mat res;
        ll r;
        for (int i = 1; i <= sz; ++i)
        {
            for (int k = 1; k <= sz; ++k)
            {
                r = m[i][k];
                for (int j = 1; j <= sz; ++j)
                {
                    res.m[i][j] += r * T.m[k][j],
                    res.m[i][j] %= mod; 
                }
            }
        }
        return res;
    }

    mat operator ^(ll x) const 
    {
        mat res, bas;
        for (int i = 1; i <= sz; ++i) res.m[i][i] = 1;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j) bas.m[i][j] = m[i][j] % mod;
        }
        while (x)
        {
            if (x & 1) res = res * bas;
            bas = bas * bas;
            x >>= 1;
        }
        return res;
    }
};

mat m1, m2;

int main()
{
    
}
```



### 高斯消元

```c++
#include<bits/stdc++.h>
using namespace std;
double a[105][105];
double eps = 1e-8;
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) //增广矩阵
    {
        for (int j = 1; j <= n + 1; j++)
        {
            scanf("%lf", &a[i][j]);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        int maxv = i;
        for (int j = i + 1; j <= n; ++j)
        {
            if (fabs(a[j][i]) > fabs(a[maxv][i])) maxv = j; //找到一个大于0的行
        }
        for (int j = 1; j <= n + 1; ++j) swap(a[i][j], a[maxv][j]); //交换每个元素
        if (fabs(a[i][i]) < eps) //如果没有大于0的则没有唯一解
        {
            printf("No Solution");
            return 0;
        }
        for (int j = n + 1; j >= 1; j--) a[i][j] = a[i][j] / a[i][i]; //将a[i][i]变为1
        for (int j = 1; j <= n; ++j)
        {
            if (j != i)
            {
                double temp = a[j][i] / a[i][i];
                for (int k = 1; k <= n + 1; ++k) a[j][k] -= a[i][k] * temp;
            }
        }   
    }
    for (int i = 1; i <= n; ++i) printf("%.2f\n", a[i][n + 1]);
}
```



### 线性基

```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
int n, m, s;

struct lb
{
    ll d[64];
    void print()
    {
        for (int i = 0; i <= 62; i++) if (d[i]) printf("%d:%lld\n", i, d[i]);
    }
    lb(){memset(d, 0, sizeof(d));}
    void operator += (ll x)
    {
        for (int i = 62; i >= 0; i--)
        {
            if (!(x & (1ll << i))) continue;
            if (d[i]) x ^= d[i];
            else {d[i] = x; break;}
        }
    }
    ll& operator [](int x)
    {
        return d[x];
    }

    void operator += (lb &x)
    {
        for (int i = 62; i >= 0; i--)
        {
            if (x[i]) *this += x[i];
        }
    }

    friend lb operator + (lb &x, lb & y)
    {
        lb z = x;
        for (int i = 62; i >= 0; i--)
        {
            if (y[i]) z += y[i];
        }
        return z;
    }
    ll calc()
    {
        ll res = 0;
        for (int i = 62; i >= 0; i--) if ((res ^ d[i]) > res) res ^= d[i];
        return res;
    }
};
int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);cout.tie(NULL);
    lb x1;
}
```



### 01分数规划

```c++
//二分法

#include<iostream>
#include<math.h>
#include<algorithm>
using namespace std;
const double eps = 1e-4;
const int N = 1e3 + 10;
double a[N], b[N];
double w[N];
int n, k;

bool check(double mid)
{
    for (int i = 1; i <= n; i++) w[i] = a[i] - mid * b[i];
        sort(w + 1, w + 1 + n);
    double ans = 0;
    for (int i = min(k + 1, n); i <= n; i++) ans += w[i];
    if (ans >= eps) return true;
    else return false;
}

int main()
{
    while(scanf("%d%d", &n, &k) != EOF)
    {
        if (n == 0 && k == 0) break;
        for (int i = 1; i <= n; i++) scanf("%lf", &a[i]);
        for (int i = 1; i <= n; i++) scanf("%lf", &b[i]);
        double l = 0, r = 2e9;
        for (int i = 1; i <= 50; i++)   
        {
            double mid = (l + r) / 2;
            if (check(mid)) l = mid;
            else r = mid;
        }
        printf("%.0f\n", r * 100);
    }
}
```



```c++
//Dinkelbach算法

#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const double eps = 1e-4;
int n, k;
double a[1005], b[1005];

pair<double, int>w[1005];

int main()
{
    while(scanf("%d%d",&n, &k) != EOF)
    {
        if (n == 0 && k == 0) break;
        double l = 0;
        for (int i = 1; i <= n; i++)
        {
            scanf("%lf", &a[i]);
        }
        for (int i = 1; i <= n; i++)
        {
            scanf("%lf", &b[i]);
        }

        double ans = 0;
        while(1)
        {
            ans = l;
            for (int i = 1; i <= n; i++)
            {
                w[i].first = a[i] - l * b[i], w[i].second = i;
            }
            sort(w + 1, w + 1 + n);
            double A = 0, B = 0;
            for (int i = min(k + 1, n); i <= n; i++)
            {
                A += a[w[i].second], B += b[w[i].second];
            }
            l = A / B;
            if (fabs(ans - l) < eps) break;
        }
        printf("%.0f\n", ans * 100);
    }
}

```



### 埃氏筛

```cpp
void get_prime()
{
    not_prime[1] = 1;
    for (int i = 2; i * i <= 1e7; i++)
    {
        if (!not_prime[i]) 
        {
            prime[++cnt] = i;
            for (int j = i * i; j <= 1e7; j += i) not_prime[j] = 1;
        }
    }
    return;
}
```



### 欧拉筛

```cpp
void get_prime()
{
    not_prime[1] = 1;
    for (int i = 2; i <= N; i++)
    {
        if (!not_prime[i]) prime[++cnt] = i;
        for (int j = 1; j <= cnt && prime[j] * i <= N; j++)
        {
            not_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
}
```



### 大整数区间筛法

```c++
ll l, r;
void get_prime()  //求l, r区间的素数
{
    not_prime[1] = 1;
    for (int i = 2; i <= sqrt(r); i++)
    {
        if (not_prime[i] == 0) 
        {
            for (int j = 2 * i; j <= sqrt(r); j += i)
            {
                not_prime[j] = 1;
            }
            for (ll j = max(2ll, (l + i - 1) / i * i); j < r; j += i)
            {
                nprime[j - l] = 1;
            }
        }
    }
}
```



### Miller-Rabin（大整数判断是否为素数）

```c++
#include <map>
#include <iostream>
#include <algorithm>
#include <ctime>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N = 105;

ll mul(ll a, ll b, ll mod) //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

/*
 *作用:计算(a,b)的最大公约数
 *时间复杂度:logn
 */
ll gcd(ll a, ll b)
{
    return b == 0 ? a : gcd(b, a % b);
}

/*
 *作用:计算a^b 模 mod
 *时间复杂度:logb
 */
ll ksm(ll a, ll b, ll mod)
{
    ll res = 1 % mod;
    while (b)
    {
        if (b & 1)
            res = mul(res, a, mod);
        b >>= 1;
        a = mul(a, a, mod);
    }
    return (res + mod) % mod;
}

/*
 *作用:判断x是否是质数
 *时间复杂度: O(klog^3n)
 */
bool Miller_Rabin(ll x)
{
    if (x < 3 || x % 2 == 0)
        return x == 2;

    ll u = x - 1, t = 0;
    while (u % 2 == 0)
    {
        u /= 2;
        t++;
    }
    ll tim = 7;
    ll primes[15] = {2, 325, 9375, 28178, 40775, 9780504, 1795265922};

    for (int i = 0; i < tim; i++)
    {
        ll v = ksm(primes[i], u, x);

        if (v == 1 || v == x - 1 || v == 0)
            continue;

        for (int j = 1; j <= t; j++)
        {
            v = mul(v, v, x);
            if (v == x - 1 && j != t)
            {
                v = 1;
                break;
            }

            if (v == 1)
                return 0;
        }

        if (v != 1)
            return 0;
    }
    return true;
}

int main()
{
    ll n;
    while(cin >> n)
    {
        cout << Miller_Rabin(n) << endl;
    }
}
```

### Pollard_rho（大整数分解因数）

```c++
#include <map>
#include <iostream>
#include <algorithm>
#include <ctime>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N = 105;

ll mul(ll a, ll b, ll mod) //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

/*
 *作用:计算(a,b)的最大公约数
 *时间复杂度:logn
 */
ll gcd(ll a, ll b)
{
    return b == 0 ? a : gcd(b, a % b);
}

/*
 *作用:计算a^b 模 mod
 *时间复杂度:logb
 */
ll ksm(ll a, ll b, ll mod)
{
    ll res = 1 % mod;
    while (b)
    {
        if (b & 1)
            res = mul(res, a, mod);
        b >>= 1;
        a = mul(a, a, mod);
    }
    return (res + mod) % mod;
}

/*
 *作用:判断x是否是质数
 *时间复杂度: O(klog^3n)
 */
bool miller_rabin(ll x)
{
    if (x < 3 || x % 2 == 0)
        return x == 2;

    ll u = x - 1, t = 0;
    while (u % 2 == 0)
    {
        u /= 2;
        t++;
    }
    ll tim = 7;
    ll primes[15] = {2, 325, 9375, 28178, 40775, 9780504, 1795265922};

    for (int i = 0; i < tim; i++)
    {
        ll v = ksm(primes[i], u, x);

        if (v == 1 || v == x - 1 || v == 0)
            continue;

        for (int j = 1; j <= t; j++)
        {
            v = mul(v, v, x);
            if (v == x - 1 && j != t)
            {
                v = 1;
                break;
            }

            if (v == 1)
                return 0;
        }

        if (v != 1)
            return 0;
    }
    return true;
}

ll f(ll x, ll c, ll n) // Pollard_Rho需要用到
{
    return (mul(x, x, n) + c) % n; //这里不用快速乘会爆long long
}

/*
 *作用:找出x的因子(非质数,非最大)
 *注意:使用该函数前应该保证x不是质数，否则会TLE
 *时间复杂度:O(n^{1}{4}))
 */
ll Pollard_Rho(ll x)
{
    ll s = 0, t = 0;
    ll c = (ll)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    ll val = 1;
    for (goal = 1;; goal <<= 1, s = t, val = 1)
    {
        for (step = 1; step <= goal; ++step)
        {
            t = f(t, c, x);
            val = mul(val, abs(t - s), x);
            if ((step % 127) == 0)
            {
                ll d = gcd(val, x);
                if (d > 1)
                    return d;
            }
        }
        ll d = gcd(val, x);
        if (d > 1)
            return d;
    }
}

/*
 *作用:找出x的最大因子(非质数)
 *时间复杂度:O(n^{1}{4}))
 */
map<ll, int> mp;
ll max_factor = 0;
void fac(ll x)
{
    if (x <= max_factor || x < 2)
        return;

    if (miller_rabin(x))
    {
        // max_factor = max(max_factor, x);
        // cout << x << endl;
        mp[x]++;
        return;
    }

    ll p = x;
    while (p >= x)
        p = Pollard_Rho(x);

    // while ((x % p) == 0)
    //     x /= p;

    fac(p), fac(x / p);
}

ll ned[110];
int main()
{
    srand(time(0));
    ll a, b;
    cin >> b;
    while (b--)
    {
        cin >> a;
        // ll rea, reb;
        // ll sum = 2e18;
        mp.clear();
        fac(a);
        // int p = 0;
        ll ans = 0;
        for (map<ll, int>::iterator it = mp.begin(); it != mp.end(); it++) //第一键值为质因数的大小，第二键值为个数
        {
            ans = max(ans, it->first);
        }
        if (ans == a) cout<<"Prime"<<endl;
        else cout<<ans<<endl;
    }
    return 0;
}
```



## <a id="game">博弈</a>





## <a id="Other">杂项</a>
