# 目录

## [字符串](#STRING)





## [数据结构](#DS)







## [图论](#Graph)






## [动态规划](#DP)





## [数论](#Numbertheory)







## [博弈](#game)





## [计算几何](#geometry)





## [杂项](#Other)







# 模板

## <a id="STRING">字符串</a>

### 双哈希
```cpp
typedef pair<int, int> hashv;
const ll mod1 = 1000000007;
const ll mod2 = 1000000009;

const int N = ?;
hashv pw[N]; //预处理幂次

hashv operator+ (hashv a, hashv b)
{
    int c1 = a.first + b.first;
    int c2 = a.second + b.second;
    if(c1 >= mod1)
        c1 -= mod1;
    if(c2 >= mod2)
        c2 -= mod2;
    return make_pair(c1, c2);
}
hashv operator- (hashv a, hashv b)
{
    int c1 = a.first - b.first;
    int c2 = a.second - b.second;
    if(c1 < 0)
        c1 += mod1;
    if(c2 < 0)
        c2 += mod2;
    return make_pair(c1, c2);
}
hashv operator* (hashv a, hashv b)
{
    return make_pair(1ll * a.first * b.first % mod1, 1ll * a.second * b.second % mod2);
}

void init() //记得调用
{
    hashv base = make_pair(13331, 23333); 
    pw[0] = make_pair(1, 1);   
}

hashv get(int l, int r) //反串就swap(l, r)
{
    return h[r] - h[l - 1] * pw[r - l + 1];
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)
        pw[i] = pw[i - 1] * base;

    for(int i = 1; i <= n; i ++)
        h[i] = h[i - 1] * base + make_pair(s[i], s[i]);
}
```

### KMP
模板
```cpp
    next[1] = 0;
    for (int i = 2, j = 0; i <= n; i++)
    {
        while (j > 0 && a[i] != a[j + 1])
            j = next[j];
        if (a[i] == a[j + 1])
            j++;
        next[i] = j;
    }

    for (int i = 1, j = 0; i <= m; i++)
    {
        while (j > 0 && (j == n || b[i] != a[j + 1]))
            j = next[j];
        if (b[i] == a[j + 1])
            j++;
        f[i] = j;
        // if (f[i] == n)，此时就是A在B中的某一次出现
    }
```
所有前缀的出现次数
```cpp
    for (int i = 0; i <= na; i++)
        cnt[i] = 1;
    for (int i = na; i >= 1; i--)
        cnt[nta[i]] += cnt[i];
```
拓展KMP
```cpp
//给定两个字符串 a,b，你要求出两个数组：
//b 的 z 函数数组 z，即 b 与 b 的每一个后缀的 LCP 长度。
//b 与 a的每一个后缀的 LCP 长度数组 p。
const int N = 2e7 + 7;
int n, m, z[N], p[N];
char a[N], b[N];

inline void Z(char *s, int n) {
    for (int i = 1; i <= n; i++) z[i] = 0;
    z[1] = n;
    for (int i = 2, l = 0, r = 0; i <= n; i++) {
        if (i <= r) z[i] = min(z[i-l+1], r - i + 1);
        while (i + z[i] <= n && s[i+z[i]] == s[z[i]+1]) ++z[i];
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
}

inline void exkmp(char *s, int n, char *t, int m) {
    Z(t, m);
    for (int i = 1; i <= n; i++) p[i] = 0;
    for (int i = 1, l = 0, r = 0; i <= n; i++) {
        if (i <= r) p[i] = min(z[i-l+1], r - i + 1);
        while (i + p[i] <= n && s[i+p[i]] == t[p[i]+1]) ++p[i];
        if (i + p[i] - 1 > r) l = i, r = i + p[i] - 1;
    }
}

int main() {
    rds(a, n), rds(b, m);
    exkmp(a, n, b, m);
    ll ans = 0;
    for (int i = 1; i <= m; i++) ans ^= 1ll * i * (z[i] + 1);
    print(ans);
    ans = 0;
    for (int i = 1; i <= n; i++) ans ^= 1ll * i * (p[i] + 1);
    print(ans);
}
```

### 马拉车
```cpp
const int MAXN = 110005;
char s[MAXN];
char A[MAXN * 2];
int B[MAXN * 2];
void Manacher(char s[], int len)
{
    int l = 0;
    A[l++] = '$';
    A[l++] = '#';
    for (int i = 0; i < len; i++)
    {
        A[l++] = s[i];
        A[l++] = '#';
    }
    A[l] = 0;
    int mx = 0;
    int id = 0;
    for (int i = 1; i < l; i++)
    {
        B[i] = mx > i ? min(B[2 * id - i], mx - i) : 1;
        while (A[i + B[i]] == A[i - B[i]])
        {
            B[i]++;
        }
        if (i + B[i] > mx)
        {
            mx = i + B[i];
            id = i;
        }
    }
}
//原位置在拓展串中位置 i * 2 + 2
//前缀中心点 i + 2, 后缀中心点 i + len + 2
//最长回文子串 (maxpos - maxlen) / 2 ~ (maxpos - maxlen) / 2 + maxlen - 2 
//从0开始，起始位置，截至位置。
/*
    if (maxlen < B[i]) {
        maxlen = B[i];
        maxpos = i;
    }
*/
//s[0] ~ s[i] 是否是回文，p[i + 2] - 1 == i + 1;
//s[i + 1] ~ s[len - 1]是否是回文, p[i + len + 2] - 1 == len - i - 1;
```

### 最小表示法
```cpp
    // 最小表示法
    int n = strlen(s + 1);
    for (int i = 1; i <= n; i++)
        s[n + i] = s[i];
    int i = 1, j = 2, k;
    while (i <= n && j <= n)
    {
        for (k = 0; k < n && s[i + k] == s[j + k]; k++)
            ;
        if (k == n)
            break; // s likes "aaaaa"
        if (s[i + k] > s[j + k]) //最大表示法 < 改成 >
        {
            i = i + k + 1;
            if (i == j)
                i++;
        }
        else
        {
            j = j + k + 1;
            if (i == j)
                j++;
        }
    }
    ans = min(i, j);
```

### AC自动机
给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。
```cpp
#include <bits/stdc++.h>
#define maxn 1000001
using namespace std;
struct kkk
{
    int son[26], flag, fail;
    void clear()
    {
        memset(son, 0, sizeof(son));
        fail = flag = 0;
    }
} trie[maxn];
int n, cnt;
char s[1000001];
queue<int> q;
void insert(char *s)
{
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        if (!trie[u].son[v])
            trie[u].son[v] = ++cnt;
        u = trie[u].son[v];
    }
    trie[u].flag++;
}
void getFail()
{
    for (int i = 0; i < 26; i++)
        trie[0].son[i] = 1; //初始化0的所有儿子都是1
    q.push(1);
    trie[1].fail = 0; //将根压入队列
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++)
        {                            //遍历所有儿子
            int v = trie[u].son[i];  //处理u的i儿子的fail，这样就可以不用记父亲了
            int Fail = trie[u].fail; //就是fafail，trie[Fail].son[i]就是和v值相同的点
            if (!v)
            {
                trie[u].son[i] = trie[Fail].son[i];
                continue;
            }                                 //不存在该节点，第二种情况
            trie[v].fail = trie[Fail].son[i]; //第三种情况，直接指就可以了
            q.push(v);                        //存在实节点才压入队列
        }
    }
}
int query(char *s)
{
    int u = 1, ans = 0, len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        int k = trie[u].son[v]; //跳Fail
        while (k > 1 && trie[k].flag != -1)
        {                                           //经过就不统计了
            ans += trie[k].flag, trie[k].flag = -1; //累加上这个位置的模式串个数，标记已经过
            k = trie[k].fail;                       //继续跳Fail
        }
        u = trie[u].son[v]; //到下一个儿子
    }
    return ans;
}
int main()
{
    cnt = 1; //代码实现细节，编号从1开始
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", s);
        insert(s);
    }
    getFail();
    scanf("%s", s);
    printf("%d\n", query(s));
    return 0;
}
```

有 N 个由小写字母组成的模式串以及一个文本串 T。
每个模式串可能会在文本串中出现多次。
你需要找出哪些模式串在文本串 T 中出现的次数最多。
```cpp
// AC自动机加强版
#include <bits/stdc++.h>
#define maxn 1000001
using namespace std;
char s[151][maxn], T[maxn];
int n, cnt, vis[maxn], ans;
struct kkk
{
    int son[26], fail, flag;
    void clear()
    {
        memset(son, 0, sizeof(son));
        fail = flag = 0;
    }
} trie[maxn];
queue<int> q;
void insert(char *s, int num)
{
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        if (!trie[u].son[v])
            trie[u].son[v] = ++cnt;
        u = trie[u].son[v];
    }
    trie[u].flag = num; //变化1：标记为第num个出现的字符串
}
void getFail()
{
    for (int i = 0; i < 26; i++)
        trie[0].son[i] = 1;
    q.push(1);
    trie[1].fail = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        int Fail = trie[u].fail;
        for (int i = 0; i < 26; i++)
        {
            int v = trie[u].son[i];
            if (!v)
            {
                trie[u].son[i] = trie[Fail].son[i];
                continue;
            }
            trie[v].fail = trie[Fail].son[i];
            q.push(v);
        }
    }
}
void query(char *s)
{
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        int k = trie[u].son[v];
        while (k > 1)
        {
            if (trie[k].flag)
                vis[trie[k].flag]++; //如果有模式串标记，更新出现次数
            k = trie[k].fail;
        }
        u = trie[u].son[v];
    }
}
void clear()
{
    for (int i = 0; i <= cnt; i++)
        trie[i].clear();
    for (int i = 1; i <= n; i++)
        vis[i] = 0;
    cnt = 1;
    ans = 0;
}
int main()
{
    while (1)
    {
        scanf("%d", &n);
        if (!n)
            break;
        clear();
        for (int i = 1; i <= n; i++)
        {
            scanf("%s", s[i]);
            insert(s[i], i);
        }
        scanf("%s", T);
        getFail();
        query(T);
        for (int i = 1; i <= n; i++)
            ans = max(vis[i], ans); //最后统计答案
        printf("%d\n", ans);
        for (int i = 1; i <= n; i++)
            if (vis[i] == ans)
                printf("%s\n", s[i]);
    }
}
```

给你一个文本串 S和 n个模式串 T1 ~ Tn;
请你分别求出每个模式串 Ti 在 S 中出现的次数。
数据不保证任意两个模式串不相同。
```cpp
#include <bits/stdc++.h>
#define maxn 2000001
using namespace std;
char s[maxn], T[maxn];
int n, cnt, vis[200051], ans, in[maxn], Map[maxn];
struct kkk
{
    int son[26], fail, flag, ans;
} trie[maxn];
queue<int> q;
void insert(char *s, int num)
{
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; ++i)
    {
        int v = s[i] - 'a';
        if (!trie[u].son[v])
            trie[u].son[v] = ++cnt;
        u = trie[u].son[v];
    }
    if (!trie[u].flag)
        trie[u].flag = num;
    Map[num] = trie[u].flag;
}
void getFail()
{
    for (int i = 0; i < 26; i++)
        trie[0].son[i] = 1;
    q.push(1);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        int Fail = trie[u].fail;
        for (int i = 0; i < 26; ++i)
        {
            int v = trie[u].son[i];
            if (!v)
            {
                trie[u].son[i] = trie[Fail].son[i];
                continue;
            }
            trie[v].fail = trie[Fail].son[i];
            in[trie[v].fail]++;
            q.push(v);
        }
    }
}
void topu()
{
    for (int i = 1; i <= cnt; ++i)
        if (in[i] == 0)
            q.push(i); //将入度为0的点全部压入队列里
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[trie[u].flag] = trie[u].ans; //如果有flag标记就更新vis数组
        int v = trie[u].fail;
        in[v]--;                    //将唯一连出去的出边fail的入度减去（拓扑排序的操作）
        trie[v].ans += trie[u].ans; //更新fail的ans值
        if (in[v] == 0)
            q.push(v); //拓扑排序常规操作
    }
}
void query(char *s)
{
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; ++i)
        u = trie[u].son[s[i] - 'a'], trie[u].ans++;
}
int main()
{
    scanf("%d", &n);
    cnt = 1;
    for (int i = 1; i <= n; ++i)
    {
        scanf("%s", s);
        insert(s, i);
    }
    getFail();
    scanf("%s", T);
    query(T);
    topu();
    for (int i = 1; i <= n; ++i)
        printf("%d\n", vis[Map[i]]);
}
```


### 后缀自动机
模板
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXLEN = 2000100;
int len[MAXLEN], link[MAXLEN], Next[MAXLEN][26];
int sz, last;
long long siz[MAXLEN];
vector<int> e[MAXLEN];
long long ans = 0;
char s[MAXLEN];
void sam_init()
{
    len[0] = 0;
    link[0] = -1;
    sz++;
    last = 0;
}
void sam_extend(int c)
{
    int cur = sz++;
    len[cur] = len[last] + 1;
    siz[cur] = 1;
    int p = last;
    while (p != -1 && !Next[p][c])
    {
        Next[p][c] = cur;
        p = link[p];
    }
    if (p == -1)
    {
        link[cur] = 0;
    }
    else
    {
        int q = Next[p][c];
        if (len[p] + 1 == len[q])
        {
            link[cur] = q;
        }
        else
        {
            int clone = sz++;
            len[clone] = len[p] + 1;
            memcpy(Next[clone], Next[q], sizeof(Next[clone]));
            link[clone] = link[q];
            while (p != -1 && Next[p][c] == q)
            {
                Next[p][c] = clone;
                p = link[p];
            }
            link[q] = link[cur]  = clone;
        }
    }
    last = cur;
}
void dfs(int x) {
    for (auto y : e[x]) {
        dfs(y);
        siz[x] += siz[y];
    }
    if (siz[x] != 1) {
        ans = max(ans, siz[x] * len[x]);
    }
}
int main()
{
    sam_init();
    scanf("%s", s);
    int n = strlen(s);
    for (int i = 0; i < n; i++) {
        sam_extend(s[i] - 'a');
    }
    for (int i = 1; i < sz; i++) {
        e[link[i]].push_back(i);
    }
    dfs(0);
    printf("%lld", ans);
}
//本质不同子串 cntu = maxlenu - maxlenlinku, 每个状态cnt累加求和
/* 拓扑排序模拟
    for (int i = 1; i < sz; i++)
        t[st[i].len]++;
    for (int i = 1; i < sz; i++)
        t[i] += t[i - 1];
    for (int i = 1; i < sz; i++)
        A[t[st[i].len]--] = i;
    for (int i = sz - 1; i >= 1; i--)
        siz[st[A[i]].link] += siz[A[i]];
    // for (int i = 1; i < sz; i++)
    //     sum[i] = siz[i] = 1;
    siz[0] = sum[0] = 0;
    for (int i = sz - 1; i >= 0; i--)
        for (int j = 0; j < 26; j++)
            if (st[A[i]].next[j])
                sum[A[i]] += sum[st[A[i]].next[j]];
*/
```

字典序第K大
```cpp
void Print(int x, int k)
{
    if (k <= siz[x])
        return;
    k -= siz[x];
    for (int i = 0; i < 26; i++)
    {
        int R = st[x].next[i];
        if (!R)
            continue;
        if (k > sum[R])
        {
            k -= sum[R];
            continue;
        }
        putchar(i + 'a');
        Print(R, k);
        return;
    }
}
```

两个字串的最长公共子串
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXLEN = 300005;
struct state
{
    int len, link;
    map<char, int> next;
};
state st[MAXLEN * 2];
int sz, last;
void sam_init()
{
    st[0].len = 0;
    st[0].link = -1;
    sz++;
    last = 0;
}
void sam_extend(int c)
{
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p = last;
    while (p != -1 && !st[p].next.count(c))
    {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1)
    {
        st[cur].link = 0;
    }
    else
    {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len)
        {
            st[cur].link = q;
        }
        else
        {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
           
            st[clone].link = st[q].link;
            while (p != -1 && st[p].next[c] == q)
            {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}
int lcs(const string &S, const string &T) {
  sam_init();
  for (int i = 0; i < S.size(); i++) sam_extend(S[i]);

  int v = 0, l = 0, best = 0, bestpos = 0;
  for (int i = 0; i < T.size(); i++) {
    while (v && !st[v].next.count(T[i])) {
      v = st[v].link;
      l = st[v].len;
    }
    if (st[v].next.count(T[i])) {
      v = st[v].next[T[i]];
      l++;
    }
    if (l > best) {
      best = l;
      bestpos = i;
    }
  }
  return best;
}

int main()
{
    string s, t;
    cin >> s >> t;
    cout << lcs(s, t);
}
```

多个字串的最长公共字串
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXLEN = 200005;
// struct state
// {
//     int len, link;
//     int Next[25];
// };
// state st[MAXLEN * 2];
int len[MAXLEN], link[MAXLEN], Next[MAXLEN][26];
int sz, last;
void sam_init()
{
    len[0] = 0;
    link[0] = -1;
    sz++;
    last = 0;
}
void sam_extend(int c)
{
    int cur = sz++;
    len[cur] = len[last] + 1;
    int p = last;
    while (p != -1 && !Next[p][c])
    {
        Next[p][c] = cur;
        p = link[p];
    }
    if (p == -1)
    {
        link[cur] = 0;
    }
    else
    {
        int q = Next[p][c];
        if (len[p] + 1 == len[q])
        {
            link[cur] = q;
        }
        else
        {
            int clone = sz++;
            len[clone] = len[p] + 1;
            // st[clone].Next = st[q].Next;
            memcpy(Next[clone], Next[q], sizeof(Next[q]));
            link[clone] = link[q];
            while (p != -1 && Next[p][c] == q)
            {
                Next[p][c] = clone;
                p = link[p];
            }
            link[q] = link[cur] = clone;
        }
    }
    last = cur;
}
int n, T[MAXLEN], A[MAXLEN], siz[MAXLEN], mn[MAXLEN], mx[MAXLEN];
int main()
{
    sam_init();
    ios::sync_with_stdio(false);
    string s;
    cin >> s;
    int slen = s.size();
    for (int i = 0; i < slen; i++) {
        sam_extend(s[i] - 'a');
    }
    for (int i = 1; i < sz; i++)
        T[len[i]]++;
    for (int i = 1; i < sz; i++)
        T[i] += T[i - 1];
    for (int i = 1; i < sz; i++)
        A[T[len[i]]--] = i;
    for (int i = 1; i < sz; i++) {
        mn[i] = 0x3f3f3f3f;
    }

    while (cin >> s) {
        for (int i = 1; i < sz; i++) mx[i] = 0;
        int v = 0, l = 0;
        slen = s.size();
        for (int i = 0; i < slen; i++) {
            while (v && !Next[v][s[i] - 'a']) {
                v = link[v];
                l = len[v];
            }
            if (Next[v][s[i] - 'a']) {
                v = Next[v][s[i] - 'a'];
                l++;
                mx[v] = max(mx[v], l);
            } 
        }
        for (int i = sz - 1; i >= 1; i--) {
            int x = A[i], fa = link[A[i]];
            mx[fa] = min(max(mx[fa], mx[x]), len[fa]);
            mn[x] = min(mn[x], mx[x]);
        }
    }

    int ans = 0;
    for (int i = 1; i < sz; i++) {
        ans = max(ans, mn[i]);
    }
    cout << ans;
}
```

长度为X的字串出现的最多次数
```cpp
    for (int i = sz - 1; i >= 1; i--) {
        int p = A[i];
        siz[Link[p]] += siz[p];
        cnt[len[p]] = max(cnt[len[p]], siz[p]);
    }
    for (int i = n; i >= 1; i--) {
        cnt[i] = max(cnt[i], cnt[i + 1]);
    }
    for (int i = 1; i <= n; i++) {
        cout << cnt[i] << '\n';
    }
```



## <a id="DS">数据结构</a>

###  单调栈

```

```



### 单调队列

```

```



### 种类并查集

```


```





### 树状数组

```cpp
struct BIT {
    ll c[N];
    void add(int x, int val) {
        for (int i = x; i < N; i += i & -i) {
            c[i] += val;
        }
    }
    ll ask(int x) {
        ll ans = 0;
        for (int i = x; i; i -= i & -i) {
            ans += c[i];
        }
        return ans;
    }
};
```



### 高维树状数组

```cpp
struct BIT {
    ll bit[N][N];
    void add(int x, int y, ll d) {
        for(int i = x; i <= n; i += lowbit(i))
            for(int j = y; j <= m; j += lowbit(j))
                bit[i][j] += d;
    };
    ll query(int x, int y) {
        ll res = 0;
        for(int i = x; i; i -= lowbit(i))
            for(int j = y; j; j -= lowbit(j))
                res += bit[i][j];
        return res;
    }
};
BIT a;
```





### 线段树

基础线段树（加法）

```cpp
struct Seg_Tree {
    struct node {
        int l, r;
        ll s;
        
    } seg[N * 4];
    void pushup(int k)
    {

    }
    void set_tag(int k, int l, int r)
    {

    }
    void pushdown(int k)
    {   

    }
    void build(int k, int l, int r) //记得调用
    {
        seg[k] = {l, r};
        if(l == r) {
            seg[k].s = ?;
            seg[k].lazy = ?;
            ?
            return;
        }
        int mid = (l + r) >> 1;
        build(k << 1, l, mid);
        build(k << 1 | 1, mid + 1, r);
        pushup(k);
    }
    void interval_modify(int k, int ql, int qr, ll v) //区间修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
        {
            set_tag(k, ); //更新
            return;
        }
        pushdown(k);
        int mid = (l + r) >> 1;
        if(ql <= mid)
            modify(k << 1, l, mid, v);
        if(mid < qr)
            modify(k << 1 | 1, mid + 1, r, v);
        pushup(k);
    }    
    ll interval_query(int k, int ql, int qr)
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
            return seg[k].s;
        pushdown(k);
        int mid = (l + r) >> 1;
        ll res = 0;
        if(ql <= mid)
            res += query(k << 1, ql, qr), res %= mod;
        if(mid < qr)
            res += query(k << 1 | 1, ql, qr), res %= mod;
        return res;
    }
    void point_modify(int k, int pos, ll v) //单点修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
        {
            //
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            point_modify(k << 1, pos, v);
        else
            point_modify(k << 1 | 1, pos, v);
        pushup(k);
    }
    ll point_query(int k, int pos)
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
            return seg[k].s;
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            return point_modify(k << 1, pos);
        else
            return point_modify(k << 1 | 1, pos);
        pushup(k);
    }
};
Seg_Tree T1;

int main()
{
    //调用
    T1.build(1, 1, n);  
    T1.interval_modify(1, 2, 4, 5);
}
```

维护和，平方和，立方和（加乘）

```cpp
const int N = 100005;
const int mod = 10007;

int n, m;
struct node {
    int tag_add, tag_mul;
    int sum1, sum2, sum3;
} seg[N * 4];
int a[N];

void update(int k, int len, int add, int mul)
{
    seg[k].tag_mul = seg[k].tag_mul * mul % mod;
    seg[k].tag_add = seg[k].tag_add * mul % mod;
    seg[k].tag_add = ((seg[k].tag_add + add) % mod + mod) % mod;
    if(mul != 1)
    {
        seg[k].sum1 = 1ll * seg[k].sum1 * mul % mod;
        seg[k].sum2 = 1ll * seg[k].sum2 * mul % mod * mul % mod;
        seg[k].sum3 = 1ll * seg[k].sum3 * mul % mod * mul % mod * mul % mod;
    }
    if(add != 0)
    {
        int add2 = add * add % mod, add3 = add2 * add % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum2 % mod * add % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum1 % mod * add2 % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 1ll * len * add3 % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 2ll * seg[k].sum1 % mod * add % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 1ll * len * add2 % mod) + mod) % mod;
        seg[k].sum1 = ((seg[k].sum1 + 1ll * len * add % mod) + mod) % mod;
    }
}

void pushup(int k)
{
    seg[k].sum1 = (seg[k << 1].sum1 + seg[k << 1 | 1].sum1) % mod;
    seg[k].sum2 = (seg[k << 1].sum2 + seg[k << 1 | 1].sum2) % mod;
    seg[k].sum3 = (seg[k << 1].sum3 + seg[k << 1 | 1].sum3) % mod;
}

void build(int k, int l, int r) //记得调用
{
    seg[k].tag_add = 0;
    seg[k].tag_mul = 1;
    if(l == r) {
        seg[k].sum1 = a[l];
        seg[k].sum2 = seg[k].sum1 * a[l] % mod;
        seg[k].sum3 = seg[k].sum2 * a[l] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    pushup(k);
}

void pushdown(int k, int len)
{
    update(k << 1, (len - (len >> 1)), seg[k].tag_add, seg[k].tag_mul);
    update(k << 1 | 1, len >> 1, seg[k].tag_add, seg[k].tag_mul);
    seg[k].tag_add = 0, seg[k].tag_mul = 1;
}

void modify(int k, int l, int r, int ql, int qr, int add, int mul)
{
    if(ql <= l && r <= qr)
    {
        update(k, r - l + 1, add, mul);
        return;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    if(ql <= mid)
        modify(k << 1, l, mid, ql, qr, add, mul);
    if(mid < qr)
        modify(k << 1 | 1, mid + 1, r, ql, qr, add, mul);
    pushup(k);
}

int query(int k, int l, int r, int ql, int qr, int d)
{
    if(ql <= l && r <= qr)
    {
        if(d == 1)  return seg[k].sum1;
        if(d == 2)  return seg[k].sum2;
        if(d == 3)  return seg[k].sum3;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    int res = 0;
    if(ql <= mid)
        res += query(k << 1, l, mid, ql, qr, d), res %= mod;
    if(mid < qr)
        res += query(k << 1 | 1, mid + 1, r, ql, qr, d), res %= mod;
    pushup(k);
    return res;
}

void init()
{
    for(int i = 1; i <= n; i ++)    
        a[i] = 0;
}

int main()
{
    while(scanf("%d%d", &n, &m))
    {
        if(!n && !m)
            break;
        init();
        build(1, 1, n);

        while(m --)
        {
            int op, l, r, v;
            scanf("%d%d%d%d", &op, &l, &r, &v);
            if(op == 1)
                modify(1, 1, n, l, r, v, 1);
            else if(op == 2)
                modify(1, 1, n, l, r, 0, v);
            else if(op == 3)
                modify(1, 1, n, l, r, v, 0);
            else 
                printf("%d\n", query(1, 1, n, l, r, v));
        }
    }
    return 0;
}
```



### 李超线段树

```txt
维护两个操作
1、插入一条直线、直线覆盖长度为整个区间
2、查询现在所有直线中当x = x'时，y'的最大和最小值
```

```c++
//线段长度全部覆盖[1, n]
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define ll long long
#define db long double
#define pii pair<ll,ll>
#define lowbit(x) x&-x
#define u64 unsigned long long
#define MAX_INF 0x3f
#define MAX_INF_VAL 0x3f3f3f3f
#define MAX_INF_VAL_LL 0x3f3f3f3f3f3f3f3f
using namespace std;
const int mod = 1e9 + 7;
const int N = 1e6 + 100;
inline ll read() 
{
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node
{
    ll k, b;  //斜率k和常数b
}seg[N * 4];
int n, m;
ll cal (node &f, int x)  //函数值
{
    return f.k * x + f.b;
}
void modify(int k, int l, int r, int ql, int qr, node w)
{
    int mid = l + r >> 1;
    if (ql == l && r == qr)
    {
        if (seg[k].k == MAX_INF_VAL_LL)
        {
            seg[k] = w;
            return;
        }
        ll yl_ori = cal(seg[k], ql);
        ll yr_ori = cal(seg[k], qr);
        ll yl_new = cal(w, ql);
        ll yr_new = cal(w, qr);
        if (yl_ori >= yl_new && yr_ori >= yr_new) return;
        else if (yl_ori <= yl_new && yr_ori <= yr_new)
        {
            seg[k] = w;
        }
        else
        {
            ll ymid_ori = cal(seg[k], mid);
            ll ymid_new = cal(w, mid);
            if (ymid_new > ymid_ori) //中间点谁高谁覆盖的面积多
            {
                if (yl_new <= yl_ori)
                    modify (k<<1, l, mid, ql, mid, seg[k]);
                else
                    modify (k<<1|1, mid + 1, r, mid + 1, qr, seg[k]);
                seg[k] = w;
            }
            else 
            {
                if (yl_new <= yl_ori)
                    modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
                else 
                    modify(k<<1, l, mid, ql, mid, w);
            }
        }
    }
}
ll query(int k, int l, int r, int x)
{
    ll res;
    if (seg[k].k == MAX_INF_VAL_LL) res = -MAX_INF_VAL_LL;
    else res = cal(seg[k], x);
    if (l == r) return res;
    int mid = l + r >> 1;
    if (x <= mid) 
        res = max(res, query(k<<1, l, mid, x));
    else 
        res = max(res, query(k<<1|1, mid+1, r, x));
    return res;
}
int main()
{
    // std::ios::sync_with_stdio(false);
    // cin.tie(NULL);cout.tie(NULL);
    scanf("%d%d",&n, &m);
    memset(seg, MAX_INF, sizeof(seg));
    int opt, x, y;
    while(m--)
    {
        scanf("%d%d", &opt, &x);
        if (opt == 0) 
        {
            scanf("%d",&y);
            modify(1, 1, n, 1, n, {x, y});
        }
        else 
        {
            printf("%lld\n", query(1, 1, n, x)) ;
        }
    }
}
```



```txt
维护两个操作
1、插入一条线段（不覆盖整个区间了）
2、给定一个x' 求y'的最大值
```

```c++
//分区间
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define ll long long
#define db long double
#define pii pair<double,ll>
#define lowbit(x) x&-x
#define u64 unsigned long long
#define MAX_INF 0x3f
#define MAX_INF_VAL 0x3f3f3f3f
#define MAX_INF_VAL_LL 0x3f3f3f3f3f3f3f3f
using namespace std;
const int mod = 39989;
const int N = 39989 + 100;
inline ll read() 
{
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node
{
    double k, b;
    int id;
}seg[N * 4];

struct line
{
    double k, b;
    int id;
}l[100005];
int n, m, cnt;
double cal (node &f, int x)
{
    return f.k * x + f.b;
}
void modify(int k, int l, int r, int ql, int qr, node w)
{
    int mid = l + r >> 1;
    if (ql == l && r == qr)
    {
        if (seg[k].id == 0)
        {
            seg[k] = w;
            return;
        }
        double yl_ori = cal(seg[k], ql);
        double yr_ori = cal(seg[k], qr);
        double yl_new = cal(w, ql);
        double yr_new = cal(w, qr);
        if (yl_ori >= yl_new && yr_ori >= yr_new) return;
        else if (yl_ori <= yl_new && yr_ori <= yr_new)
        {
            seg[k] = w;
        }
        else
        {
            double ymid_ori = cal(seg[k], mid);
            double ymid_new = cal(w, mid);
            if (ymid_new > ymid_ori) //中间点谁高谁覆盖的面积多
            {
                if (yl_new <= yl_ori)
                    modify (k<<1, l, mid, ql, mid, seg[k]);
                else
                    modify (k<<1|1, mid + 1, r, mid + 1, qr, seg[k]);
                seg[k] = w;
            }
            else 
            {
                if (yl_new <= yl_ori)
                    modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
                else 
                    modify(k<<1, l, mid, ql, mid, w);
            }
        }
        return;
    }
    if (qr <= mid) modify(k<<1, l, mid, ql, qr, w);
    else if (ql > mid) modify(k<<1|1, mid + 1, r, ql, qr, w);
    else modify(k<<1, l, mid, ql, mid, w), modify(k<<1|1, mid + 1, r, mid + 1, qr, w);
}

pii find(pii x, pii y)
{
    if (x.first > y.first) return x;
    else if (x.first < y.first) return y;
    else
    {
        if (x.second < y.second) return x;
        else return y;
    }
}
pii query(int k, int l, int r, int x)
{
    pii res;
    if (seg[k].id == 0) res = {-1e18, 0};
    else res = {cal(seg[k], x), seg[k].id};
    if (l == r) return res;
    int mid = l + r >> 1;
    if (x <= mid) 
        res = find(res, query(k<<1, l, mid, x));
    else 
        res = find(res, query(k<<1|1, mid+1, r, x));
    return res;
}
ll ans = 0;
int main()
{
    // std::ios::sync_with_stdio(false);
    // cin.tie(NULL);cout.tie(NULL);
    scanf("%d",&m);
    int opt, x, y, xx, yy;
    while(m--)
    {
        scanf("%d", &opt);
        if (opt == 0) 
        {
            scanf("%d",&x);
            x = (x + ans - 1)%39989+1;
            ans = query(1, 1, mod, x).second;
            printf("%lld\n", ans);
        }
        else 
        {
            scanf("%d%d%d%d",&x, &y, &xx, &yy);
            x = (x + ans - 1) % mod + 1;    //这一块是因为题目强制在线
            y = (y + ans - 1) % 1000000000 + 1;
            xx = (xx + ans - 1) % mod + 1;
            yy = (yy + ans - 1) % 1000000000 + 1;
            if (x > xx) swap(x, xx), swap(y, yy);
            double k, b;
            if (x == xx) k = 0, b = max(y, yy);
            else k = (1.0 * (y - yy)) / (x - xx), b = y - (1.0 * (y - yy)) / (x - xx) * x;
            modify(1, 1, mod, x, xx, {k, b, ++cnt});
        }
    }
}
```



### Treap

```
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1. 插入数值 x。
2. 删除数值 x (若有多个相同的数，应只删除一个)。
3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4. 查询排名为 x 的数值。
5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。
```

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100005, inf = 0x3f3f3f3f;

struct node {
    int l, r;
    int key, val;
    int cnt, sz;
} tr[N];

int rt, idx = 0;

void pushup(int p)
{
    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;
}

int get_node(int key)
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].sz = 1;
    return idx;
}

void build()
{
    get_node(-inf);
    get_node(inf);
    //添加两个哨兵防止越界
    rt = 1;
    tr[1].r = 2;
    pushup(rt);
}

void rrotate(int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r);
    pushup(p);
}

void lrotate(int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l);
    pushup(p);
}

void insert(int &p, int key)
{
    if(!p)  p = get_node(key);
    else if(tr[p].key == key)   tr[p].cnt ++;
    else if(tr[p].key > key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val > tr[p].val)
            rrotate(p);
    }
    else if(tr[p].key < key)
    {
        insert(tr[p].r, key);
        if(tr[tr[p].r].val > tr[p].val)
            lrotate(p);
    }
    pushup(p);
}

void remove(int &p, int key)
{
    if(!p)  return;
    if(tr[p].key == key) 
    {
        if(tr[p].cnt > 1)
            tr[p].cnt --;
        else if(tr[p].l || tr[p].r) //非叶子
        {
            if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                rrotate(p);
                remove(tr[p].r, key);
            }
            else
            {
                lrotate(p);
                remove(tr[p].l, key);
            }
        }
        else
            p = 0;
    }
    else if(tr[p].key > key)
        remove(tr[p].l, key);
    else 
        remove(tr[p].r, key);
    pushup(p);
}

int query_rank_by_key(int p, int key) //该数值排第几
{
    if(!p)  return 0; //查询无效
    if(tr[p].key == key)
        return tr[tr[p].l].sz + 1;
    else if(tr[p].key > key)
        return query_rank_by_key(tr[p].l, key);
    else
        return tr[tr[p].l].sz + tr[p].cnt + query_rank_by_key(tr[p].r, key);
}

int query_key_by_rank (int p, int rk) //求第rk个数的数值
{
    if(!p)  return inf; //查无此人
    if(tr[tr[p].l].sz >= rk)    
        return query_key_by_rank(tr[p].l, rk);
    else if(tr[tr[p].l].sz + tr[p].cnt >= rk)
        return tr[p].key;
    else 
        return query_key_by_rank(tr[p].r, rk - tr[tr[p].l].sz - tr[p].cnt);
}   

int get_prev(int p, int key) //严格小于key的最大数
{
    if(!p)  return -inf;
    if(tr[p].key >= key)
        return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key) //严格大于key的最小数
{
    if(!p)  return inf;
    if(tr[p].key <= key)   
        return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();
    int n;
    scanf("%d", &n);
    while(n --)
    {
        int opt, x;
        scanf("%d%d", &opt, &x);
        if(opt == 1)
            insert(rt, x);
        else if(opt == 2)
            remove(rt, x);
        else if(opt == 3)
            printf("%d\n", query_rank_by_key(rt, x) - 1); //因为加入了两个哨兵 所以需要微调
        else if(opt == 4)
            printf("%d\n", query_key_by_rank(rt, x + 1)); //因为加入了两个哨兵 所以需要微调
        else if(opt == 5)
            printf("%d\n", get_prev(rt, x));
        else 
            printf("%d\n", get_next(rt, x));
    }
}
```





### Splay

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 100;

struct node
{
    int cnt, ch[2], val, size, fa;
    int tag;
}tr[N];
int tot, root, sstk[N], stop;
int x, y, z;

inline void update(int u)
{
    tr[u].size = tr[tr[u].ch[0]].size + tr[tr[u].ch[1]].size + tr[u].cnt;
}

void rot (int x)
{
    int fa = tr[x].fa;
    int gfa = tr[fa].fa;
    int k = (tr[fa].ch[1] == x);
    tr[gfa].ch[(tr[gfa].ch[1] == fa)] = x;
    tr[x].fa = gfa;
    tr[fa].ch[k] = tr[x].ch[k ^ 1];
    tr[tr[x].ch[k ^ 1]].fa = fa;
    tr[x].ch[k ^ 1] = fa;
    tr[fa].fa = x;
    update(fa), update(x);
}

void splay(int x, int s)
{
    while(tr[x].fa != s)
    {
        int y = tr[x].fa, z = tr[y].fa;
        if (z != s)
            (tr[z].ch[0] == y) ^ (tr[y].ch[0] == x)?rot(x):rot(y); 
        rot(x);
    }
    if (s == 0)
        root = x;
}

void rk(int x)
{
    int u = root;
    if(!u) return;
    while(tr[u].ch[x > tr[u].val] && x != tr[u].val)
        u = tr[u].ch[x > tr[u].val];
    splay(u, 0);
}


void ins(int x)
{
    int u = root, fa = 0;
    while (u && tr[u].val != x)
    {
        fa = u;
        u = tr[u].ch[x > tr[u].val];
    }
    if (u) tr[u].cnt++;
    else 
    {
        u = ++tot;
        if (fa)
            tr[fa].ch[x > tr[fa].val] = u;
        tr[u].ch[0] = tr[u].ch[1] = 0;
        tr[tot].fa = fa;
        tr[tot].val = x;
        tr[tot].cnt = 1;
        tr[tot].size = 1;
    }
    splay(u, 0);
}

int next(int x, int f) //f代表左子树
{
    rk(x);
    int u = root;
    if (tr[u].val > x && f)
        return u;
    if (tr[u].val < x && !f) return u;
    u = tr[u].ch[f];
    while(tr[u].ch[f ^ 1]) u = tr[u].ch[f ^ 1];
    return u;
}

void push_down(int root) //区间翻转
{
    if (tr[root].tag)
    {
        swap(tr[root].ch[0], tr[root].ch[1]);
        tr[root].tag ^= 1;
        tr[tr[root].ch[0]].tag ^= 1;
        tr[tr[root].ch[0]].tag ^= 1;
    }
    return ;
}
int kth(int x)
{
    int u = root;
    if(tr[u].size < x) return 0;
    while(1)
    {
        int y = tr[u].ch[0];
        cout << y <<" "<<x << endl;
        if (x > tr[y].size + tr[u].cnt)
        {
            x -= tr[y].size + tr[u].cnt;
            u = tr[u].ch[1];
        }
        else if (tr[y].size >= x) u = y;
        else return tr[u].val;
    }
}

int links(int root1, int root2)
{
    if (!root1 || !root2) return root1|root2;
    root1 = kth(tr[root1].size);
    tr[root1].ch[1] = root2;
    tr[root2].fa = root1;
    update(root1);
    return root1;
}

void cuts(int root, int k, int &root1, int &root2)
{
    if (k == 0)
    {
        root1 = 0;
        root2 = root;
        return;
    }
    root1 = kth(k);
    root2 = tr[root1].ch[1];
    tr[root1].ch[1] = tr[root2].fa = 0;
    update(root1);
    return;
}
void push_until(int root)
{
    while(root)
    {
        sstk[++stop] = root;
        root = tr[root].fa;
    }
    while(stop)
    {
        push_down(sstk[stop--]);
    }
    return;
}
void del(int x)
{
    int pre = next(x, 0);
    int nex = next(x, 1);
    splay(pre, 0);
    splay(nex, pre);
    int Del = tr[nex].ch[0];
    if (tr[Del].cnt > 1)
    {
        tr[Del].cnt--;
        splay(Del, 0);
    }
    else
        tr[nex].ch[0] = 0;
}

int main()
{
    int T;
    ins(1e9);
    ins(-1e9);
    scanf("%d",&T);
    while(T--)
    {
        int op, x;
        scanf("%d%d",&op, &x);
        if (op == 1) ins(x);
        else if (op == 2) del(x);
        else if (op == 3) rk(x),  printf("%d\n",tr[tr[root].ch[0]].size);
        else if (op == 4) printf("%d\n",kth(x + 1));
        else if (op == 5) printf("%d\n",tr[next(x, 0)].val);
        else if (op == 6) printf("%d\n",tr[next(x, 1)].val);
    }
}
```





### 笛卡尔树

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 2e5 + 100;

int stk[N], top, a[N], l[N], r[N], n;

void build()
{
    stack<int>st;
    int root = 0;
    for (int i = 1; i <= n; i++) l[i] = r[i] = 0;
    for (int i = 1; i <= n; i++)
    {
        int last = 0;
        while(!st.empty() && a[st.top()] > a[i])
        {
            last = st.top();
            st.pop();
        }
        if (!st.empty()) r[st.top()] = i;
        else root = i; //手写栈的话,k = 0就root; 即为栈底
        l[i] = last;
        st.push(i);
    }
}

// void build()
// {
//  int top = 0;
//  for (int i = 1; i <= n; i++) l[i] = r[i] = 0;
//  for (int i = 1; i <= n; i++)
//  {
//      int k = top;
//      while (k > 0 && a[stk[k-1]] > a[i]) --k; //弹出栈顶找到第一个小于他的节点
//      if (k) r[stk[k-1]] = i; //该节点的右节点指向i
//      if (k < top) l[i] = stk[k]; //如果弹出过 那么他就得把之前的右跟换成左根
//      stk[k++] = i;
//      top = k;
//  }

//  for (int i = 1; i <= n; i++)
//  {
//      if (l[i]) add(i, l[i]);
//      if (r[i]) add(i, r[i]);
//  }
// }

int main()
{
    scanf("%d",&n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d",&a[i]);
    }
    build();
}
```





### 主席树

```

```





## <a id="Graph">图论</a>




## <a id="DP">动态规划</a>
### 四边形不等式优化DP
```cpp
#define ll long long
#define ld long double
const int N = 100006;
int n, l, p;
ll s[N];
ld f[N];
struct Q {
    int x, l, r;
} q[N];

int get(int i, int L, int R) {
    int ans;
    while (L <= R) {
        int mid = (L + R) >> 1;
        if (q[mid].l <= i && q[mid].r >= i) {
            ans = mid;
            break;
        }
        if (i >= q[mid].l) L = mid + 1;
        else R = mid - 1;
    }
    return q[ans].x;
}

ld calc(int i, int j) {
    ld ans = 1, num = abs((ld)(s[i] - s[j] + i - j - 1 - l));
    for (int i = 1; i <= p; i++) ans *= num;
    return ans + f[j];
}

void insert(int i, int &L, int &R) {
    int w = -1;
    while (L <= R)
        if (calc(q[R].l, i) <= calc(q[R].l, q[R].x)) w = q[R--].l;
        else {
            if (calc(q[R].r, q[R].x) > calc(q[R].r, i))  {
                int l = q[R].l, r = q[R].r;
                while (l < r) {
                    int mid = (l + r) >> 1;
                    if (calc(mid, i) > calc(mid, q[R].x)) l = mid + 1;
                    else r = mid;
                }
                q[R].r = l - 1;
                w = l;
            }
            break;
        }
    if (w != -1) {
        q[++R].l = w;
        q[R].r = n;
        q[R].x = i;
    }
}

void G() {
    cin >> n >> l >> p;
    for (int i = 1; i <= n; i++) {
        char str[37];
        scanf("%s", str);
        s[i] = s[i-1] + strlen(str);
    }
    int L = 1, R = 1;
    q[1].x = 0;
    q[1].l = 1;
    q[1].r = n;
    for (int i = 1; i <= n; i++) {
        int j = get(i, L, R);
        f[i] = calc(i, j);
        while (L <= R && q[L].r <= i) ++L;
        q[L].l = i + 1;
        insert(i, L, R);
    }
    if (f[n] > 1e18) puts("Too hard to arrange");
    else cout << (ll)f[n] << endl;
    for (int i = 1; i <= 20; i++) putchar('-');
    puts("");
}

int main() {
    int t;
    cin >> t;
    while (t--) G();
    return 0;
}

// 分治写法 f(i) = min(w(l, r))
void DP(int l, int r, int k_l, int k_r) {
  int mid = (l + r) / 2, k = k_l;
  // 求状态f[mid]的最优决策点
  for (int i = k_l; i <= min(k_r, mid - 1); ++i)
    if (w(i, mid) < w(k, mid)) k = i;
  f[mid] = w(k, mid);
  // 根据决策单调性得出左右两部分的决策区间，递归处理
  if (l < mid) DP(l, mid - 1, k_l, k);
  if (r > mid) DP(mid + 1, r, k, k_r);
}
```



## <a id="Numbertheory">数论</a> 

### 普通操作

```c++
ll gcd(ll a, ll b)  //gcd
{
    return __gcd(a, b);
}

ll lcm(ll a, ll b)  //lcm
{
    return a / gcd(a, b) * b;
}

ll mul(ll a, ll b)  //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

ll ksm(ll a, ll b)  //快速幂
{
    ll res = 1;
    while(b)
    {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll extend_gcd(ll a, ll b, ll &x, ll &y) //返回d = gcd(a, b); 并返回 ax + by = d的特解x, y
{
    if (b == 0) {x = 1; y = 0; return a;}
    ll d = extend_gcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```



### 矩阵快速幂

```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e2 + 10;
// const int mod = 1e9 + 7;
ll k, mod;
int sz;
struct mat
{
    
    ll m[N][N];
    mat() {memset(m, 0, sizeof(m));}
    void clear() {memset(m, 0, sizeof(m));}
    mat operator - (const mat& T) const 
    {
        mat res;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j)
            {
                res.m[i][j] = ((m[i][j] - T.m[i][j]) % mod + mod) % mod;
            }
        }

        return res;
    }

    mat operator + (const mat& T) const
    {
        mat res;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j)
            {
                res.m[i][j] = (m[i][j] + T.m[i][j]) % mod;
            }
        }

        return res;
    }

    mat operator * (const mat& T) const
    {
        mat res;
        ll r;
        for (int i = 1; i <= sz; ++i)
        {
            for (int k = 1; k <= sz; ++k)
            {
                r = m[i][k];
                for (int j = 1; j <= sz; ++j)
                {
                    res.m[i][j] += r * T.m[k][j],
                    res.m[i][j] %= mod; 
                }
            }
        }
        return res;
    }

    mat operator ^(ll x) const 
    {
        mat res, bas;
        for (int i = 1; i <= sz; ++i) res.m[i][i] = 1;
        for (int i = 1; i <= sz; ++i)
        {
            for (int j = 1; j <= sz; ++j) bas.m[i][j] = m[i][j] % mod;
        }
        while (x)
        {
            if (x & 1) res = res * bas;
            bas = bas * bas;
            x >>= 1;
        }
        return res;
    }
};

mat m1, m2;

int main()
{
    
}
```



### 高斯消元

```c++
#include<bits/stdc++.h>
using namespace std;
double a[105][105];
double eps = 1e-8;
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) //增广矩阵
    {
        for (int j = 1; j <= n + 1; j++)
        {
            scanf("%lf", &a[i][j]);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        int maxv = i;
        for (int j = i + 1; j <= n; ++j)
        {
            if (fabs(a[j][i]) > fabs(a[maxv][i])) maxv = j; //找到一个大于0的行
        }
        for (int j = 1; j <= n + 1; ++j) swap(a[i][j], a[maxv][j]); //交换每个元素
        if (fabs(a[i][i]) < eps) //如果没有大于0的则没有唯一解
        {
            printf("No Solution");
            return 0;
        }
        for (int j = n + 1; j >= 1; j--) a[i][j] = a[i][j] / a[i][i]; //将a[i][i]变为1
        for (int j = 1; j <= n; ++j)
        {
            if (j != i)
            {
                double temp = a[j][i] / a[i][i];
                for (int k = 1; k <= n + 1; ++k) a[j][k] -= a[i][k] * temp;
            }
        }   
    }
    for (int i = 1; i <= n; ++i) printf("%.2f\n", a[i][n + 1]);
}
```



### 线性基

```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
int n, m, s;

struct lb
{
    ll d[64];
    void print()
    {
        for (int i = 0; i <= 62; i++) if (d[i]) printf("%d:%lld\n", i, d[i]);
    }
    lb(){memset(d, 0, sizeof(d));}
    void operator += (ll x)
    {
        for (int i = 62; i >= 0; i--)
        {
            if (!(x & (1ll << i))) continue;
            if (d[i]) x ^= d[i];
            else {d[i] = x; break;}
        }
    }
    ll& operator [](int x)
    {
        return d[x];
    }

    void operator += (lb &x)
    {
        for (int i = 62; i >= 0; i--)
        {
            if (x[i]) *this += x[i];
        }
    }

    friend lb operator + (lb &x, lb & y)
    {
        lb z = x;
        for (int i = 62; i >= 0; i--)
        {
            if (y[i]) z += y[i];
        }
        return z;
    }
    ll calc()
    {
        ll res = 0;
        for (int i = 62; i >= 0; i--) if ((res ^ d[i]) > res) res ^= d[i];
        return res;
    }
};
int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);cout.tie(NULL);
    lb x1;
}
```



### 01分数规划

```c++
//二分法

#include<iostream>
#include<math.h>
#include<algorithm>
using namespace std;
const double eps = 1e-4;
const int N = 1e3 + 10;
double a[N], b[N];
double w[N];
int n, k;

bool check(double mid)
{
    for (int i = 1; i <= n; i++) w[i] = a[i] - mid * b[i];
        sort(w + 1, w + 1 + n);
    double ans = 0;
    for (int i = min(k + 1, n); i <= n; i++) ans += w[i];
    if (ans >= eps) return true;
    else return false;
}

int main()
{
    while(scanf("%d%d", &n, &k) != EOF)
    {
        if (n == 0 && k == 0) break;
        for (int i = 1; i <= n; i++) scanf("%lf", &a[i]);
        for (int i = 1; i <= n; i++) scanf("%lf", &b[i]);
        double l = 0, r = 2e9;
        for (int i = 1; i <= 50; i++)   
        {
            double mid = (l + r) / 2;
            if (check(mid)) l = mid;
            else r = mid;
        }
        printf("%.0f\n", r * 100);
    }
}
```



```c++
//Dinkelbach算法

#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const double eps = 1e-4;
int n, k;
double a[1005], b[1005];

pair<double, int>w[1005];

int main()
{
    while(scanf("%d%d",&n, &k) != EOF)
    {
        if (n == 0 && k == 0) break;
        double l = 0;
        for (int i = 1; i <= n; i++)
        {
            scanf("%lf", &a[i]);
        }
        for (int i = 1; i <= n; i++)
        {
            scanf("%lf", &b[i]);
        }

        double ans = 0;
        while(1)
        {
            ans = l;
            for (int i = 1; i <= n; i++)
            {
                w[i].first = a[i] - l * b[i], w[i].second = i;
            }
            sort(w + 1, w + 1 + n);
            double A = 0, B = 0;
            for (int i = min(k + 1, n); i <= n; i++)
            {
                A += a[w[i].second], B += b[w[i].second];
            }
            l = A / B;
            if (fabs(ans - l) < eps) break;
        }
        printf("%.0f\n", ans * 100);
    }
}

```



### 埃氏筛

```cpp
void get_prime()
{
    not_prime[1] = 1;
    for (int i = 2; i * i <= 1e7; i++)
    {
        if (!not_prime[i]) 
        {
            prime[++cnt] = i;
            for (int j = i * i; j <= 1e7; j += i) not_prime[j] = 1;
        }
    }
    return;
}
```



### 欧拉筛

```cpp
void get_prime()
{
    not_prime[1] = 1;
    for (int i = 2; i <= N; i++)
    {
        if (!not_prime[i]) prime[++cnt] = i;
        for (int j = 1; j <= cnt && prime[j] * i <= N; j++)
        {
            not_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
}
```



### 大整数区间筛法

```c++
ll l, r;
void get_prime()  //求l, r区间的素数
{
    not_prime[1] = 1;
    for (int i = 2; i <= sqrt(r); i++)
    {
        if (not_prime[i] == 0) 
        {
            for (int j = 2 * i; j <= sqrt(r); j += i)
            {
                not_prime[j] = 1;
            }
            for (ll j = max(2ll, (l + i - 1) / i * i); j < r; j += i)
            {
                nprime[j - l] = 1;
            }
        }
    }
}
```



### Miller-Rabin（大整数判断是否为素数）

```c++
#include <map>
#include <iostream>
#include <algorithm>
#include <ctime>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N = 105;

ll mul(ll a, ll b, ll mod) //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

/*
 *作用:计算(a,b)的最大公约数
 *时间复杂度:logn
 */
ll gcd(ll a, ll b)
{
    return b == 0 ? a : gcd(b, a % b);
}

/*
 *作用:计算a^b 模 mod
 *时间复杂度:logb
 */
ll ksm(ll a, ll b, ll mod)
{
    ll res = 1 % mod;
    while (b)
    {
        if (b & 1)
            res = mul(res, a, mod);
        b >>= 1;
        a = mul(a, a, mod);
    }
    return (res + mod) % mod;
}

/*
 *作用:判断x是否是质数
 *时间复杂度: O(klog^3n)
 */
bool Miller_Rabin(ll x)
{
    if (x < 3 || x % 2 == 0)
        return x == 2;

    ll u = x - 1, t = 0;
    while (u % 2 == 0)
    {
        u /= 2;
        t++;
    }
    ll tim = 7;
    ll primes[15] = {2, 325, 9375, 28178, 40775, 9780504, 1795265922};

    for (int i = 0; i < tim; i++)
    {
        ll v = ksm(primes[i], u, x);

        if (v == 1 || v == x - 1 || v == 0)
            continue;

        for (int j = 1; j <= t; j++)
        {
            v = mul(v, v, x);
            if (v == x - 1 && j != t)
            {
                v = 1;
                break;
            }

            if (v == 1)
                return 0;
        }

        if (v != 1)
            return 0;
    }
    return true;
}

int main()
{
    ll n;
    while(cin >> n)
    {
        cout << Miller_Rabin(n) << endl;
    }
}
```

### Pollard_rho（大整数分解因数）

```c++
#include <map>
#include <iostream>
#include <algorithm>
#include <ctime>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N = 105;

ll mul(ll a, ll b, ll mod) //快速乘
{
    a %= mod;
    b %= mod;
    ll c = (ld)a * b / mod;
    ll res = a * b - c * mod;
    return (res % mod + mod) % mod;
}

/*
 *作用:计算(a,b)的最大公约数
 *时间复杂度:logn
 */
ll gcd(ll a, ll b)
{
    return b == 0 ? a : gcd(b, a % b);
}

/*
 *作用:计算a^b 模 mod
 *时间复杂度:logb
 */
ll ksm(ll a, ll b, ll mod)
{
    ll res = 1 % mod;
    while (b)
    {
        if (b & 1)
            res = mul(res, a, mod);
        b >>= 1;
        a = mul(a, a, mod);
    }
    return (res + mod) % mod;
}

/*
 *作用:判断x是否是质数
 *时间复杂度: O(klog^3n)
 */
bool miller_rabin(ll x)
{
    if (x < 3 || x % 2 == 0)
        return x == 2;

    ll u = x - 1, t = 0;
    while (u % 2 == 0)
    {
        u /= 2;
        t++;
    }
    ll tim = 7;
    ll primes[15] = {2, 325, 9375, 28178, 40775, 9780504, 1795265922};

    for (int i = 0; i < tim; i++)
    {
        ll v = ksm(primes[i], u, x);

        if (v == 1 || v == x - 1 || v == 0)
            continue;

        for (int j = 1; j <= t; j++)
        {
            v = mul(v, v, x);
            if (v == x - 1 && j != t)
            {
                v = 1;
                break;
            }

            if (v == 1)
                return 0;
        }

        if (v != 1)
            return 0;
    }
    return true;
}

ll f(ll x, ll c, ll n) // Pollard_Rho需要用到
{
    return (mul(x, x, n) + c) % n; //这里不用快速乘会爆long long
}

/*
 *作用:找出x的因子(非质数,非最大)
 *注意:使用该函数前应该保证x不是质数，否则会TLE
 *时间复杂度:O(n^{1}{4}))
 */
ll Pollard_Rho(ll x)
{
    ll s = 0, t = 0;
    ll c = (ll)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    ll val = 1;
    for (goal = 1;; goal <<= 1, s = t, val = 1)
    {
        for (step = 1; step <= goal; ++step)
        {
            t = f(t, c, x);
            val = mul(val, abs(t - s), x);
            if ((step % 127) == 0)
            {
                ll d = gcd(val, x);
                if (d > 1)
                    return d;
            }
        }
        ll d = gcd(val, x);
        if (d > 1)
            return d;
    }
}

/*
 *作用:找出x的最大因子(非质数)
 *时间复杂度:O(n^{1}{4}))
 */
map<ll, int> mp;
ll max_factor = 0;
void fac(ll x)
{
    if (x <= max_factor || x < 2)
        return;

    if (miller_rabin(x))
    {
        // max_factor = max(max_factor, x);
        // cout << x << endl;
        mp[x]++;
        return;
    }

    ll p = x;
    while (p >= x)
        p = Pollard_Rho(x);

    // while ((x % p) == 0)
    //     x /= p;

    fac(p), fac(x / p);
}

ll ned[110];
int main()
{
    srand(time(0));
    ll a, b;
    cin >> b;
    while (b--)
    {
        cin >> a;
        // ll rea, reb;
        // ll sum = 2e18;
        mp.clear();
        fac(a);
        // int p = 0;
        ll ans = 0;
        for (map<ll, int>::iterator it = mp.begin(); it != mp.end(); it++) //第一键值为质因数的大小，第二键值为个数
        {
            ans = max(ans, it->first);
        }
        if (ans == a) cout<<"Prime"<<endl;
        else cout<<ans<<endl;
    }
    return 0;
}
```



### 欧拉函数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
bool not_prime[N];
int prime[N], tot = 0, n, phi[N];
int main()
{
    cin >> n;
    not_prime[i] = 1, phi[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!not_prime[i]) prime[++tot] = i, phi[i] = i - 1;
        for (int j = 1; j <= tot && i * prime[j] <= n; j++)
        {
            not_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}
```



### 莫比乌斯函数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
bool vis[N];
int prime[N], Mob[N];

void Mobius_sieve()
{
    int cnt = 0;
    vis[1] = 1;
    Mob[1] = 1;
    for (int i = 2; i <= 1e5; i++)
    {
        if (!vis[i]) prime[++cnt] = i, Mob[i] = -1;
        for (int j = 1; j <= cnt && 1ll * prime[j] * i <= 1e5; j++)
        {
            vis[prime[j] * i] = 1;
            Mob[prime[j] * i] = (i % prime[j] ? -Mob[i] : 0);
            if (i % prime[j] == 0) break;
        }
    }
}

int main()
{
    Mobius_sieve();
}
```



### 狄利克雷卷积

$(f * g)(n) = \sum_{d|n}f(d)g({n\over d})$

$\epsilon = \mu * 1  \iff [n = 1] =\sum_{d|n}\mu(d)$       

$id = \phi * 1 \iff [n = \sum_{d|n}\phi(d)]$

$\phi = \mu * id$



### 莫比乌斯反演

$f(n) = \sum_{d|n}g(d) \iff g(n) = \sum_{d|n} \mu({n \over d})f(d)$ 

$f(n) = \sum_{n|m, m \le N}g(m) \iff g(n) = \sum_{n|m,m\le N}\mu({m\over n})f(m)$



### 杜教筛

快速求$M(n) = \sum_{i = 1}^n\mu(i), (n\le 10^{11})$

$M(n) = 1 - \sum_{i = 2}^nM({n\over i})$



```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 5e6;
ll phi[N + 5], prime[N + 5], cnt, mu[N + 5], not_prime[N + 5];
unordered_map<int, ll>ans_mu;
unordered_map<int, ll>ans_phi;
void init()
{
    mu[1] = 1, phi[1] = 1, not_prime[1] = 1;
    for (int i = 2; i <= 5e6; i++)
    {
        if (!not_prime[i]) prime[++cnt] = i, mu[i] = -1, phi[i] = i - 1;
        for (int j = 1; j <= cnt && prime[j] * i <= 5e6; ++j)
        {
            not_prime[prime[j] * i] = 1;
            if (i % prime[j] == 0)
            {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i <= 5e6; ++i) mu[i] += mu[i - 1], phi[i] += phi[i - 1];
}

ll get_phi(ll x)
{
    if (x <= N) return phi[x];
    if (ans_phi[x]) return ans_phi[x];
    ll ans = ((1ll + x) * x) / 2ll;
    for (int l = 2, r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        ans -= 1ll * (r - l + 1) * get_phi(x / l);
    }
    return ans_phi[x] = ans;
}

ll get_mu(ll x)
{
    if (x <= N) return mu[x];
    if (ans_mu[x]) return ans_mu[x];
    ll ans = 1;
    for (int l = 2, r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        ans -= 1ll * (r - l + 1) * get_mu(x / l);
    }
    return ans_mu[x] = ans;
}
void solve()
{
    ll x;
    cin >> x;
    cout << get_phi(x) <<" "<<get_mu(x)<<"\n";
}
int main()
{
    init();
    int t;
    cin >> t;
    while(t--)
    {
        solve();
    }
}
```



## <a id="game">博弈</a>



## <a id="geometry">计算几何</a>
### 全模板
```c++
#include <bits/stdc++.h>
using namespace std;

using point_t=long double;  //全局数据类型，可修改为 long long 等

constexpr point_t eps=1e-8;
constexpr long double PI=3.1415926535897932384l;

// 点与向量
template<typename T> struct point
{
    T x,y;

    bool operator==(const point &a) const {return (abs(x-a.x)<=eps && abs(y-a.y)<=eps);}
    bool operator<(const point &a) const {if (abs(x-a.x)<=eps) return y<a.y-eps; return x<a.x-eps;}
    bool operator>(const point &a) const {return !(*this<a || *this==a);}
    point operator+(const point &a) const {return {x+a.x,y+a.y};}
    point operator-(const point &a) const {return {x-a.x,y-a.y};}
    point operator-() const {return {-x,-y};}
    point operator*(const T k) const {return {k*x,k*y};}
    point operator/(const T k) const {return {x/k,y/k};}
    T operator*(const point &a) const {return x*a.x+y*a.y;}  // 点积
    T operator^(const point &a) const {return x*a.y-y*a.x;}  // 叉积，注意优先级
    int toleft(const point &a) const {const auto t=(*this)^a; return (t>eps)-(t<-eps);}  // to-left 测试
    T len2() const {return (*this)*(*this);}  // 向量长度的平方
    T dis2(const point &a) const {return (a-(*this)).len2();}  // 两点距离的平方

    // 涉及浮点数
    long double len() const {return sqrtl(len2());}  // 向量长度
    long double dis(const point &a) const {return sqrtl(dis2(a));}  // 两点距离
    long double ang(const point &a) const {return acosl(max(-1.0l,min(1.0l,((*this)*a)/(len()*a.len()))));}  // 向量夹角
    point rot(const long double rad) const {return {x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)};}  // 逆时针旋转（给定角度）
    point rot(const long double cosr,const long double sinr) const {return {x*cosr-y*sinr,x*sinr+y*cosr};}  // 逆时针旋转（给定角度的正弦与余弦）
};

using Point=point<point_t>;

// 极角排序
struct argcmp
{
    bool operator()(const Point &a,const Point &b) const
    {
        const auto quad=[](const Point &a)
        {
            if (a.y<-eps) return 1;
            if (a.y>eps) return 4;
            if (a.x<-eps) return 5;
            if (a.x>eps) return 3;
            return 2;
        };
        const int qa=quad(a),qb=quad(b);
        if (qa!=qb) return qa<qb;
        const auto t=a^b;
        // if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开
        return t>eps;
    }
};

// 直线
template<typename T> struct line
{
    point<T> p,v;  // p 为直线上一点，v 为方向向量

    bool operator==(const line &a) const {return v.toleft(a.v)==0 && v.toleft(p-a.p)==0;}
    int toleft(const point<T> &a) const {return v.toleft(a-p);}  // to-left 测试
    bool operator<(const line &a) const  // 半平面交算法定义的排序
    {
        if (abs(v^a.v)<=eps && v*a.v>=-eps) return toleft(a.p)==-1;
        return argcmp()(v,a.v);
    }

    // 涉及浮点数
    point<T> inter(const line &a) const {return p+v*((a.v^(p-a.p))/(v^a.v));}  // 直线交点
    long double dis(const point<T> &a) const {return abs(v^(a-p))/v.len();}  // 点到直线距离
    point<T> proj(const point<T> &a) const {return p+v*((v*(a-p))/(v*v));}  // 点在直线上的投影
};

using Line=line<point_t>;

//线段
template<typename T> struct segment
{
    point<T> a,b;

    bool operator<(const segment &s) const {return make_pair(a,b)<make_pair(s.a,s.b);}

    // 判定性函数建议在整数域使用

    // 判断点是否在线段上
    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const point<T> &p) const  
    {
        if (p==a || p==b) return -1;
        return (p-a).toleft(p-b)==0 && (p-a)*(p-b)<-eps;
    }

    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const line<T> &l) const
    {
        if (l.toleft(a)==0 || l.toleft(b)==0) return -1;
        return l.toleft(a)!=l.toleft(b);
    }
    
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const segment<T> &s) const
    {
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const line<T> l{a,b-a},ls{s.a,s.b-s.a};
        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;
    }

    // 点到线段距离
    long double dis(const point<T> &p) const
    {
        if ((p-a)*(b-a)<-eps || (p-b)*(a-b)<-eps) return min(p.dis(a),p.dis(b));
        const line<T> l{a,b-a};
        return l.dis(p);
    }

    // 两线段间距离
    long double dis(const segment<T> &s) const
    {
        if (is_inter(s)) return 0;
        return min({dis(s.a),dis(s.b),s.dis(a),s.dis(b)});
    }
};

using Segment=segment<point_t>;

// 多边形
template<typename T> struct polygon
{
    vector<point<T>> p;  // 以逆时针顺序存储

    size_t nxt(const size_t i) const {return i==p.size()-1?0:i+1;}
    size_t pre(const size_t i) const {return i==0?p.size()-1:i-1;}
    
    // 回转数
    // 返回值第一项表示点是否在多边形边上
    // 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
    pair<bool,int> winding(const point<T> &a) const
    {
        int cnt=0;
        for (size_t i=0;i<p.size();i++)
        {
            const point<T> u=p[i],v=p[nxt(i)];
            if (abs((a-u)^(a-v))<=eps && (a-u)*(a-v)<=eps) return {true,0};
            if (abs(u.y-v.y)<=eps) continue;
            const Line uv={u,v-u};
            if (u.y<v.y-eps && uv.toleft(a)<=0) continue;
            if (u.y>v.y+eps && uv.toleft(a)>=0) continue;
            if (u.y<a.y-eps && v.y>=a.y-eps) cnt++;
            if (u.y>=a.y-eps && v.y<a.y-eps) cnt--;
        }
        return {false,cnt};
    }

    // 多边形面积的两倍
    // 可用于判断点的存储顺序是顺时针或逆时针
    T area() const
    {
        T sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i]^p[nxt(i)];
        return sum;
    }

    // 多边形的周长
    long double circ() const
    {
        long double sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i].dis(p[nxt(i)]);
        return sum;
    }
};

using Polygon=polygon<point_t>;

//凸多边形
template<typename T> struct convex: polygon<T>
{
    // 闵可夫斯基和
    convex operator+(const convex &c) const  
    {
        const auto &p=this->p;
        vector<Segment> e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());
        vector<point<T>> res; res.reserve(p.size()+c.p.size());
        const auto cmp=[](const Segment &u,const Segment &v) {return argcmp()(u.b-u.a,v.b-v.a);};
        for (size_t i=0;i<p.size();i++) e1[i]={p[i],p[this->nxt(i)]};
        for (size_t i=0;i<c.p.size();i++) e2[i]={c.p[i],c.p[c.nxt(i)]};
        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());
        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());
        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);
        const auto check=[](const vector<point<T>> &res,const point<T> &u)
        {
            const auto back1=res.back(),back2=*prev(res.end(),2);
            return (back1-back2).toleft(u-back1)==0 && (back1-back2)*(u-back1)>=-eps;
        };
        auto u=e1[0].a+e2[0].a;
        for (const auto &v:edge)
        {
            while (res.size()>1 && check(res,u)) res.pop_back();
            res.push_back(u);
            u=u+v.b-v.a;
        }
        if (res.size()>1 && check(res,res[0])) res.pop_back();
        return {res};
    }

    // 旋转卡壳
    // func 为更新答案的函数，可以根据题目调整位置
    template<typename F> void rotcaliper(const F &func) const
    {
        const auto &p=this->p;
        const auto area=[](const point<T> &u,const point<T> &v,const point<T> &w){return (w-u)^(w-v);};
        for (size_t i=0,j=1;i<p.size();i++)
        {
            const auto nxti=this->nxt(i);
            func(p[i],p[nxti],p[j]);
            while (area(p[this->nxt(j)],p[i],p[nxti])>=area(p[j],p[i],p[nxti]))
            {
                j=this->nxt(j);
                func(p[i],p[nxti],p[j]);
            }
        }
    }

    // 凸多边形的直径的平方
    T diameter2() const
    {
        const auto &p=this->p;
        if (p.size()==1) return 0;
        if (p.size()==2) return p[0].dis2(p[1]);
        T ans=0;
        auto func=[&](const point<T> &u,const point<T> &v,const point<T> &w){ans=max({ans,w.dis2(u),w.dis2(v)});};
        rotcaliper(func);
        return ans;
    }
    
    // 判断点是否在凸多边形内
    // 复杂度 O(logn)
    // -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int is_in(const point<T> &a) const
    {
        const auto &p=this->p;
        if (p.size()==1) return a==p[0]?-1:0;
        if (p.size()==2) return segment<T>{p[0],p[1]}.is_on(a)?-1:0; 
        if (a==p[0]) return -1;
        if ((p[1]-p[0]).toleft(a-p[0])==-1 || (p.back()-p[0]).toleft(a-p[0])==1) return 0;
        const auto cmp=[&](const Point &u,const Point &v){return (u-p[0]).toleft(v-p[0])==1;};
        const size_t i=lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();
        if (i==1) return segment<T>{p[0],p[i]}.is_on(a)?-1:0;
        if (i==p.size()-1 && segment<T>{p[0],p[i]}.is_on(a)) return -1;
        if (segment<T>{p[i-1],p[i]}.is_on(a)) return -1;
        return (p[i]-p[i-1]).toleft(a-p[i-1])>0;
    }

    // 凸多边形关于某一方向的极点
    // 复杂度 O(logn)
    // 参考资料：https://codeforces.com/blog/entry/48868
    template<typename F> size_t extreme(const F &dir) const
    {
        const auto &p=this->p;
        const auto check=[&](const size_t i){return dir(p[i]).toleft(p[this->nxt(i)]-p[i])>=0;};
        const auto dir0=dir(p[0]); const auto check0=check(0);
        if (!check0 && check(p.size()-1)) return 0;
        const auto cmp=[&](const Point &v)
        {
            const size_t vi=&v-p.data();
            if (vi==0) return 1;
            const auto checkv=check(vi);
            const auto t=dir0.toleft(v-p[0]);
            if (vi==1 && checkv==check0 && t==0) return 1;
            return checkv^(checkv==check0 && t<=0);
        };
        return partition_point(p.begin(),p.end(),cmp)-p.begin();
    }

    // 过凸多边形外一点求凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    // 必须保证点在多边形外
    pair<size_t,size_t> tangent(const point<T> &a) const
    {
        const size_t i=extreme([&](const point<T> &u){return u-a;});
        const size_t j=extreme([&](const point<T> &u){return a-u;});
        return {i,j};
    }

    // 求平行于给定直线的凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    pair<size_t,size_t> tangent(const line<T> &a) const
    {
        const size_t i=extreme([&](...){return a.v;});
        const size_t j=extreme([&](...){return -a.v;});
        return {i,j};
    }
};

using Convex=convex<point_t>;

// 圆
struct Circle
{
    Point c;
    long double r;

    bool operator==(const Circle &a) const {return c==a.c && abs(r-a.r)<=eps;}
    long double circ() const {return 2*PI*r;}  // 周长
    long double area() const {return PI*r*r;}  // 面积

    // 点与圆的关系
    // -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &p) const {const long double d=p.dis(c); return abs(d-r)<=eps?-1:d<r-eps;}

    // 直线与圆关系
    // 0 相离 | 1 相切 | 2 相交
    int relation(const Line &l) const
    {
        const long double d=l.dis(c);
        if (d>r+eps) return 0;
        if (abs(d-r)<=eps) return 1;
        return 2;
    }

    // 圆与圆关系
    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &a) const
    {
        if (*this==a) return -1;
        const long double d=c.dis(a.c);
        if (d>r+a.r+eps) return 0;
        if (abs(d-r-a.r)<=eps) return 1;
        if (abs(d-abs(r-a.r))<=eps) return 3;
        if (d<abs(r-a.r)-eps) return 4;
        return 2;
    }

    // 直线与圆的交点
    vector<Point> inter(const Line &l) const
    {
        const long double d=l.dis(c);
        const Point p=l.proj(c);
        const int t=relation(l);
        if (t==0) return vector<Point>();
        if (t==1) return vector<Point>{p};
        const long double k=sqrt(r*r-d*d);
        return vector<Point>{p-(l.v/l.v.len())*k,p+(l.v/l.v.len())*k};
    }

    // 圆与圆交点
    vector<Point> inter(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1 || t==0 || t==4) return vector<Point>();
        Point e=a.c-c; e=e/e.len()*r;
        if (t==1 || t==3) 
        {
            if (r*r+d*d-a.r*a.r>=-eps) return vector<Point>{c+e};
            return vector<Point>{c-e};
        }
        const long double costh=(r*r+d*d-a.r*a.r)/(2*r*d),sinth=sqrt(1-costh*costh);
        return vector<Point>{c+e.rot(costh,-sinth),c+e.rot(costh,sinth)};
    }

    // 圆与圆交面积
    long double inter_area(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1) return area();
        if (t<2) return 0;
        if (t>2) return min(area(),a.area());
        const long double costh1=(r*r+d*d-a.r*a.r)/(2*r*d),costh2=(a.r*a.r+d*d-r*r)/(2*a.r*d);
        const long double sinth1=sqrt(1-costh1*costh1),sinth2=sqrt(1-costh2*costh2);
        const long double th1=acos(costh1),th2=acos(costh2);
        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);
    }

    // 过圆外一点圆的切线
    vector<Line> tangent(const Point &a) const
    {
        const int t=is_in(a);
        if (t==1) return vector<Line>();
        if (t==-1)
        {
            const Point v={-(a-c).y,(a-c).x};
            return vector<Line>{{a,v}};
        }
        Point e=a-c; e=e/e.len()*r;
        const long double costh=r/c.dis(a),sinth=sqrt(1-costh*costh);
        const Point t1=c+e.rot(costh,-sinth),t2=c+e.rot(costh,sinth);
        return vector<Line>{{a,t1-a},{a,t2-a}};
    }

    // 两圆的公切线
    vector<Line> tangent(const Circle &a) const
    {
        const int t=relation(a);
        vector<Line> lines;
        if (t==-1 || t==4) return lines;
        if (t==1 || t==3)
        {
            const Point p=inter(a)[0],v={-(a.c-c).y,(a.c-c).x};
            lines.push_back({p,v});
        }
        const long double d=c.dis(a.c);
        const Point e=(a.c-c)/(a.c-c).len();
        if (t<=2)
        {
            const long double costh=(r-a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c+d1*a.r,v2=a.c+d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        if (t==0)
        {
            const long double costh=(r+a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c-d1*a.r,v2=a.c-d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        return lines;
    }

    // 圆的反演
    tuple<int,Circle,Line> inverse(const Line &l) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        if (l.toleft(c)==0) return {2,null_c,l};
        const Point v=l.toleft(c)==1?Point{l.v.y,-l.v.x}:Point{-l.v.y,l.v.x};
        const long double d=r*r/l.dis(c);
        const Point p=c+v/v.len()*d;
        return {1,{(c+p)/2,d/2},null_l};
    }
    
    tuple<int,Circle,Line> inverse(const Circle &a) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        const Point v=a.c-c;
        if (a.is_in(c)==-1)
        {
            const long double d=r*r/(a.r+a.r);
            const Point p=c+v/v.len()*d;
            return {2,null_c,{p,{-v.y,v.x}}};
        }
        if (c==a.c) return {1,{c,r*r/a.r},null_l};
        const long double d1=r*r/(c.dis(a.c)-a.r),d2=r*r/(c.dis(a.c)+a.r);
        const Point p=c+v/v.len()*d1,q=c+v/v.len()*d2;
        return {1,{(p+q)/2,p.dis(q)/2},null_l};
    }
};

// 圆与多边形面积交
long double area_inter(const Circle &circ,const Polygon &poly)
{
    const auto cal=[](const Circle &circ,const Point &a,const Point &b)
    {
        if ((a-circ.c).toleft(b-circ.c)==0) return 0.0l;
        const auto ina=circ.is_in(a),inb=circ.is_in(b);
        const Line ab={a,b-a};
        if (ina && inb) return ((a-circ.c)^(b-circ.c))/2;
        if (ina && !inb)
        {
            const auto t=circ.inter(ab);
            const Point p=t.size()==1?t[0]:t[1];
            const long double ans=((a-circ.c)^(p-circ.c))/2;
            const long double th=(p-circ.c).ang(b-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        if (!ina && inb)
        {
            const Point p=circ.inter(ab)[0];
            const long double ans=((p-circ.c)^(b-circ.c))/2;
            const long double th=(a-circ.c).ang(p-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        const auto p=circ.inter(ab);
        if (p.size()==2 && Segment{a,b}.dis(circ.c)<=circ.r+eps)
        {
            const long double ans=((p[0]-circ.c)^(p[1]-circ.c))/2;
            const long double th1=(a-circ.c).ang(p[0]-circ.c),th2=(b-circ.c).ang(p[1]-circ.c);
            const long double d1=circ.r*circ.r*th1/2,d2=circ.r*circ.r*th2/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d1+d2;
            return ans-d1-d2;
        }
        const long double th=(a-circ.c).ang(b-circ.c);
        if ((a-circ.c).toleft(b-circ.c)==1) return circ.r*circ.r*th/2;
        return -circ.r*circ.r*th/2;
    };

    long double ans=0;
    for (size_t i=0;i<poly.p.size();i++)
    {
        const Point a=poly.p[i],b=poly.p[poly.nxt(i)];
        ans+=cal(circ,a,b);
    }
    return ans;
}

// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
Convex convexhull(vector<Point> p)
{
    vector<Point> st;
    if (p.empty()) return Convex{st};
    sort(p.begin(),p.end());
    const auto check=[](const vector<Point> &st,const Point &u)
    {
        const auto back1=st.back(),back2=*prev(st.end(),2);
        return (back1-back2).toleft(u-back1)<=0;
    };
    for (const Point &u:p)
    {
        while (st.size()>1 && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    size_t k=st.size();
    p.pop_back(); reverse(p.begin(),p.end());
    for (const Point &u:p)
    {
        while (st.size()>k && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    st.pop_back();
    return Convex{st};
}

// 半平面交
// 排序增量法，复杂度 O(nlogn)
// 输入与返回值都是用直线表示的半平面集合
vector<Line> halfinter(vector<Line> l, const point_t lim=1e9)
{
    const auto check=[](const Line &a,const Line &b,const Line &c){return a.toleft(b.inter(c))<0;};
    // 无精度误差的方法，但注意取值范围会扩大到三次方
    /*const auto check=[](const Line &a,const Line &b,const Line &c)
    {
        const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);
        return p.toleft(q)<0;
    };*/
    l.push_back({{-lim,0},{0,-1}}); l.push_back({{0,-lim},{1,0}});
    l.push_back({{lim,0},{0,1}}); l.push_back({{0,lim},{-1,0}});
    sort(l.begin(),l.end());
    deque<Line> q;
    for (size_t i=0;i<l.size();i++)
    {
        if (i>0 && l[i-1].v.toleft(l[i].v)==0 && l[i-1].v*l[i].v>eps) continue;
        while (q.size()>1 && check(l[i],q.back(),q[q.size()-2])) q.pop_back();
        while (q.size()>1 && check(l[i],q[0],q[1])) q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v)<=0) return vector<Line>();
        q.push_back(l[i]);
    }
    while (q.size()>1 && check(q[0],q.back(),q[q.size()-2])) q.pop_back();
    while (q.size()>1 && check(q.back(),q[0],q[1])) q.pop_front();
    return vector<Line>(q.begin(),q.end());
}

// 点集形成的最小最大三角形
// 极角序扫描线，复杂度 O(n^2logn)
// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)
pair<point_t,point_t> minmax_triangle(const vector<Point> &vec)
{
    if (vec.size()<=2) return {0,0};
    vector<pair<int,int>> evt;
    evt.reserve(vec.size()*vec.size());
    point_t maxans=0,minans=numeric_limits<point_t>::max();
    for (size_t i=0;i<vec.size();i++)
    {
        for (size_t j=0;j<vec.size();j++)
        {
            if (i==j) continue;
            if (vec[i]==vec[j]) minans=0;
            else evt.push_back({i,j});
        }
    }
    sort(evt.begin(),evt.end(),[&](const pair<int,int> &u,const pair<int,int> &v)
    {
        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];
        return argcmp()({du.y,-du.x},{dv.y,-dv.x});
    });
    vector<size_t> vx(vec.size()),pos(vec.size());
    for (size_t i=0;i<vec.size();i++) vx[i]=i;
    sort(vx.begin(),vx.end(),[&](int x,int y){return vec[x]<vec[y];});
    for (size_t i=0;i<vx.size();i++) pos[vx[i]]=i;
    for (auto [u,v]:evt)
    {
        const size_t i=pos[u],j=pos[v];
        const size_t l=min(i,j),r=max(i,j);
        const Point vecu=vec[u],vecv=vec[v];
        if (l>0) minans=min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));
        if (r<vx.size()-1) minans=min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));
        maxans=max({maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))});
        if (i<j) swap(vx[i],vx[j]),pos[u]=j,pos[v]=i;
    }
    return {minans,maxans};
}

// 判断多条线段是否有交点
// 扫描线，复杂度 O(nlogn)
bool segs_inter(const vector<Segment> &segs)
{
    if (segs.empty()) return false;
    using seq_t=tuple<point_t,int,Segment>;
    const auto seqcmp=[](const seq_t &u, const seq_t &v)
    {
        const auto [u0,u1,u2]=u;
        const auto [v0,v1,v2]=v;
        if (abs(u0-v0)<=eps) return make_pair(u1,u2)<make_pair(v1,v2);
        return u0<v0-eps;
    };
    vector<seq_t> seq;
    for (auto seg:segs)
    {
        if (seg.a.x>seg.b.x+eps) swap(seg.a,seg.b);
        seq.push_back({seg.a.x,0,seg});
        seq.push_back({seg.b.x,1,seg});
    }
    sort(seq.begin(),seq.end(),seqcmp);
    point_t x_now;
    auto cmp=[&](const Segment &u, const Segment &v)
    {
        if (abs(u.a.x-u.b.x)<=eps || abs(v.a.x-v.b.x)<=eps) return u.a.y<v.a.y-eps;
        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)<((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;
    };
    multiset<Segment,decltype(cmp)> s{cmp};
    for (const auto [x,o,seg]:seq)
    {
        x_now=x;
        const auto it=s.lower_bound(seg);
        if (o==0)
        {
            if (it!=s.end() && seg.is_inter(*it)) return true;
            if (it!=s.begin() && seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        }
        else
        {
            if (next(it)!=s.end() && it!=s.begin() && (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        }
    }
    return false;
}

// 多边形面积并
// 轮廓积分，复杂度 O(n^2logn)，n为边数
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Polygon> &polys)
{
    const size_t siz=polys.size();
    vector<vector<pair<Point,Point>>> segs(siz);
    const auto check=[](const Point &u,const Segment &e){return !((u<e.a && u<e.b) || (u>e.a && u>e.b));};

    auto cut_edge=[&](const Segment &e,const size_t i)
    {
        const Line le{e.a,e.b-e.a};
        vector<pair<Point,int>> evt;
        evt.push_back({e.a,0}); evt.push_back({e.b,0});
        for (size_t j=0;j<polys.size();j++)
        {
            if (i==j) continue;
            const auto &pj=polys[j];
            for (size_t k=0;k<pj.p.size();k++)
            {
                const Segment s={pj.p[k],pj.p[pj.nxt(k)]};
                if (le.toleft(s.a)==0 && le.toleft(s.b)==0)
                {
                    evt.push_back({s.a,0});
                    evt.push_back({s.b,0});
                }
                else if (s.is_inter(le))
                {
                    const Line ls{s.a,s.b-s.a};
                    const Point u=le.inter(ls);
                    if (le.toleft(s.a)<0 && le.toleft(s.b)>=0) evt.push_back({u,-1});
                    else if (le.toleft(s.a)>=0 && le.toleft(s.b)<0) evt.push_back({u,1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        if (e.a>e.b) reverse(evt.begin(),evt.end());
        int sum=0;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            const Point u=evt[i].first,v=evt[i+1].first;
            if (!(u==v) && check(u,e) && check(v,e)) segs[sum].push_back({u,v});
            if (v==e.b) break;
        }
    };
    
    for (size_t i=0;i<polys.size();i++)
    {
        const auto &pi=polys[i];
        for (size_t k=0;k<pi.p.size();k++)
        {
            const Segment ei={pi.p[k],pi.p[pi.nxt(k)]};
            cut_edge(ei,i);
        }
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(segs[i].begin(),segs[i].end());
        int cnt=0;
        for (size_t j=0;j<segs[i].size();j++)
        {
            if (j>0 && segs[i][j]==segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);
            else cnt=0,sum+=segs[i][j].first^segs[i][j].second;
        }
        ans[i]=sum/2;
    }
    return ans;
}

// 圆面积并
// 轮廓积分，复杂度 O(n^2logn)
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Circle> &circs)
{
    const size_t siz=circs.size();
    using arc_t=tuple<Point,long double,long double,long double>;
    vector<vector<arc_t>> arcs(siz);
    const auto eq=[](const arc_t &u,const arc_t &v)
    {
        const auto [u1,u2,u3,u4]=u;
        const auto [v1,v2,v3,v4]=v;
        return u1==v1 && abs(u2-v2)<=eps && abs(u3-v3)<=eps && abs(u4-v4)<=eps;
    };

    auto cut_circ=[&](const Circle &ci,const size_t i)
    {
        vector<pair<long double,int>> evt;
        evt.push_back({-PI,0}); evt.push_back({PI,0});
        int init=0;
        for (size_t j=0;j<circs.size();j++)
        {
            if (i==j) continue;
            const Circle &cj=circs[j];
            if (ci.r<cj.r-eps && ci.relation(cj)>=3) init++;
            const auto inters=ci.inter(cj);
            if (inters.size()==1) evt.push_back({atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0});
            if (inters.size()==2)
            {
                const Point dl=inters[0]-ci.c,dr=inters[1]-ci.c;
                long double argl=atan2l(dl.y,dl.x),argr=atan2l(dr.y,dr.x);
                if (abs(argl+PI)<=eps) argl=PI;
                if (abs(argr+PI)<=eps) argr=PI;
                if (argl>argr+eps)
                {
                    evt.push_back({argl,1}); evt.push_back({PI,-1});
                    evt.push_back({-PI,1}); evt.push_back({argr,-1});
                }
                else
                {
                    evt.push_back({argl,1});
                    evt.push_back({argr,-1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        int sum=init;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            if (abs(evt[i].first-evt[i+1].first)>eps) arcs[sum].push_back({ci.c,ci.r,evt[i].first,evt[i+1].first});
            if (abs(evt[i+1].first-PI)<=eps) break;
        }
    };

    const auto oint=[](const arc_t &arc)
    {
        const auto [cc,cr,l,r]=arc;
        if (abs(r-l-PI-PI)<=eps) return 2.0l*PI*cr*cr;
        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));
    };

    for (size_t i=0;i<circs.size();i++)
    {
        const auto &ci=circs[i];
        cut_circ(ci,i);
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(arcs[i].begin(),arcs[i].end());
        int cnt=0;
        for (size_t j=0;j<arcs[i].size();j++)
        {
            if (j>0 && eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);
            else cnt=0,sum+=oint(arcs[i][j]);
        }
        ans[i]=sum/2;
    }
    return ans;
}

```



## <a id="Other">杂项</a>
### 离散化
```cpp
    vector<int> a(n), b(n);
    for(int &x : a)
        cin >> x;

    sort(a.begin(), a.end());
    a.erase(unique(a.begin(), a.end()), a.end());
    for(int i = 1; i <= n; i ++)
        b[i] = lower_bound(a.begin(), a.end(), b[i]) - a.begin();
```

### 三分
```cpp
//浮点数三分
double get(double left, double right)
{
    double mid_l, mid_r;
    while (fabs(right - left) >= 1E-6)
    {
        mid_l = left + (right - left) / 3;
        mid_r = left + (right - left) / 3 * 2;
        if (f(mid_l) < f(mid_r))
            left = mid_l;
        else
            right = mid_r;
    }
    return left;
}
//整数三分
void get(ll left, ll right)
{
    ll mid_l, mid_r;
    while (left < right)
    {
        // cout << mid_l << " " << mid_r << '\n';
        mid_l = left + (right - left) / 3;
        mid_r = right - (right - left) / 3;
        if (f(mid_l) > f(mid_r))
            left = mid_l + 1;
        else
            right = mid_r - 1;
    }
    double ans = f(left);
    ans = min(ans, f(left - 1));
    ans = min(ans, f(left + 1));
    printf("%.10lf", ans);
}
```

### 高精度

```c++
const int MAXN = 200;// 字符大小 ， 没压位
struct BigInt
{
	int len, s[MAXN];
	BigInt () // 初始化
	{
		memset(s, 0, sizeof(s));
		len = 1;
	}
	BigInt (int num) { *this = num; }
	BigInt (const char *num) { *this = num; } //让this 指 针 指 向 当 前 字 符 串
	BigInt operator = (const int num)
	{
		char s[MAXN];
		sprintf(s, "%d", num); //sprintf 函 数 将 整 型 映 到 字 符 串 中
		*this = s;
		return *this; // 再 将 字 符 串 转 到 下 面 字 符 串 转 化 的 函 数 中
	}
	BigInt operator = (const char *num)
	{
		for(int i = 0; num[i] == '0'; num++) ; // 去前导 0
		len = strlen(num);
		for(int i = 0; i < len; i++) s[i] = num[len-i-1] - '0'; // 反着存
		return *this;
	}
	BigInt operator + (const BigInt &b) const // 对应 位 相加 ， 最为简单
	{
		BigInt c;
		c.len = 0;
		for(int i = 0, g = 0; g || i < max(len, b.len); i++)
		{
			int x = g;
			if(i < len) x += s[i];
			if(i < b.len) x += b.s[i];
			c.s[c.len++] = x % 10; // 关 于 加 法 进 位
			g = x / 10;
		}
		return c;
	}
	BigInt operator += (const BigInt &b) // 如上 文 所说 ， 此 类 运 算 符 皆 如 此 重 载
	{
		*this = *this + b;
		return *this;
	}
	void clean() // 由 于 接 下 来 的 运 算 不 能 确 定 结 果 的 长 度 ， 先 大 而 估 之 然 后 再 查
	{
		while(len > 1 && !s[len -1]) len --; // 首位部分 ‘0’ 故 删 除 该 部 分 长 度
	}
	BigInt operator * (const BigInt &b) // 乘 法 重 载 在 于 列 竖 式 ， 再 将 竖 式 中 的 数 转 为 抽 象 ， 即 可  出 运 算 法 则 。
	{
		BigInt c;
		c.len = len + b.len;
		for(int i = 0; i < len; i++)
		{
			for(int j = 0; j < b.len; j++)
			{
				c.s[i+j] += s[i] * b.s[j];// 不 妨 列 个 竖 式 看 一 看
			}
		}
		for(int i = 0; i < c.len; i++) // 关于进位 ， 与加 法 意同
		{
			c.s[i+1] += c.s[i]/10;
			c.s[i] %= 10;
		}
		c.clean(); // 我 们 估 的 位 数 是 a+b 的长度和 ， 但 可 能 比 它 小 （1*1 = 1）
		return c;
	}
	BigInt operator *= (const BigInt &b)
	{
		*this = *this * b;
		return *this;
	}
	BigInt operator - (const BigInt &b) // 对应 位 相减 ， 加 法 的 进 位 改 为 借 1
	{ // 不考 虑 负数
		BigInt c;
		c.len = 0;
		for(int i = 0, g = 0; i < len; i++)
		{
			int x = s[i] - g;
			if(i < b.len) x -= b.s[i]; // 可 能 长 度 不 等

			if(x >= 0) g = 0; // 是 否 向 上 移 位 借 1
			else
			{
				g = 1;
				x += 10;
			}
			c.s[c.len++] = x;
		}
		c.clean();
		return c;
	}
	BigInt operator -= (const BigInt &b)
	{
		*this = *this - b;
		return *this;
	}
	BigInt operator / (const BigInt &b) // 运 用 除 是 减 的 本 质 ， 不停地减 ， 直 到 小 于 被 减 数
	{
		BigInt c, f = 0; // 可 能 会 在 使 用 减 法 时 出 现 高 精 度 运 算
		for(int i = len -1; i >= 0; i--) // 正常顺序 ， 从 最 高 位 开 始
		{
			f = f*10; // 上 面 位 的 剩 余 到 下 一 位 *10
			f.s[0] = s[i]; // 加上 当 前位
			while(f >= b)
			{
				f -= b;
				c.s[i]++;
			}
		}
		c.len = len; // 估最长位
		c.clean();
		return c;
	}	
	BigInt operator /= (const BigInt &b)
	{
		*this = *this / b;
		return *this;
	}
	BigInt operator % (const BigInt &b) // 取 模 就 是 除 完 剩 下 的
	{
		BigInt r = *this / b;
		r = *this - r*b;
		r.clean();
		return r;
	}
	BigInt operator %= (const BigInt &b)
	{
		*this = *this % b;
		return *this;
	}
	bool operator < (const BigInt &b) // 字 符 串 比 较 原 理
	{
		if(len != b.len) return len < b.len;
		for(int i = len -1; i != -1; i--)
		{
			if(s[i] != b.s[i]) return s[i] < b.s[i];
		}
		return false;
	}
	bool operator > (const BigInt &b) // 同理
	{
		if(len != b.len) return len > b.len;
		for(int i = len -1; i != -1; i--)
		{
			if(s[i] != b.s[i]) return s[i] > b.s[i];
		}
		return false;
	}
	bool operator == (const BigInt &b)
	{
		return !(*this > b) && !(*this < b);
	}
	bool operator != (const BigInt &b)
	{
		return !(*this == b);
	}
	bool operator <= (const BigInt &b)
	{
		return *this < b || *this == b;
	}
	bool operator >= (const BigInt &b)
	{
		return *this > b || *this == b;
	}
	string str() const // 将 结 果 转 化 为 字 符 串 （ 用于输出 ）
	{
		string res = "";
		for(int i = 0; i < len; i++) res = char(s[i]+'0')+res;
		return res;
	}
};

istream& operator >> (istream &in, BigInt &x) // 重载 输 入流
{
	string s;
	in >> s;
	x = s.c_str(); //string 转化为 char[]
	return in;
}

ostream& operator << (ostream &out, const BigInt &x) // 重载 输出 流
{
	out << x.str();
	return out;
}
```

INT_128
```cpp
#define int __int128 
// 先用int调试通过，提交前#define int __int128
int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch))
    {
        if(ch == '-')   f = -1;
        ch = getchar();
    }
    while(isdigit(ch))
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(int x)
{
    if(x < 0)
        putchar('-'), x = -x;
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
```
