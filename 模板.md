# 目录

## [字符串](#STRING)





## [数据结构](#DS)







## [图论](#Graph)






## [动态规划](#DP)





## [数论](#Numbertheory)







## [博弈](#game)







## [杂项](#Other)







# 模板

## <a id="STRING">字符串</a>

### 双哈希

```cpp
typedef pair<int, int> hashv;
const ll mod1 = 1000000007;
const ll mod2 = 1000000009;

const int N = ?;
hashv pw[N]; //预处理幂次

hashv operator+ (hashv a, hashv b)
{
    int c1 = a.first + b.first;
    int c2 = a.second + b.second;
    if(c1 >= mod1)
        c1 -= mod1;
    if(c2 >= mod2)
        c2 -= mod2;
    return make_pair(c1, c2);
}
hashv operator- (hashv a, hashv b)
{
    int c1 = a.first - b.first;
    int c2 = a.second - b.second;
    if(c1 < 0)
        c1 += mod1;
    if(c2 < 0)
        c2 += mod2;
    return make_pair(c1, c2);
}
hashv operator* (hashv a, hashv b)
{
    return make_pair(1ll * a.first * b.first % mod1, 1ll * a.second * b.second % mod2);
}

void init() //记得调用
{
    hashv base = make_pair(13331, 23333); 
    pw[0] = make_pair(1, 1);   
}

hashv get(int l, int r) //反串就swap(l, r)
{
    return h[r] - h[l - 1] * pw[r - l + 1];
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)
        pw[i] = pw[i - 1] * base;

    for(int i = 1; i <= n; i ++)
        h[i] = h[i - 1] * base + make_pair(s[i], s[i]);
}
```









## <a id="DS">数据结构</a>

###  单调栈

```

```



### 单调队列

```

```



### 种类并查集

```


```





### 树状数组

```cpp
struct BIT {
    ll c[N];
    void add(int x, int val) {
        for (int i = x; i < N; i += i & -i) {
            c[i] += val;
        }
    }
    ll ask(int x) {
        ll ans = 0;
        for (int i = x; i; i -= i & -i) {
            ans += c[i];
        }
        return ans;
    }
};
```



### 高维树状数组

```cpp
struct BIT {
    ll bit[N][N];
    void add(int x, int y, ll d) {
        for(int i = x; i <= n; i += lowbit(i))
            for(int j = y; j <= m; j += lowbit(j))
                bit[i][j] += d;
    };
    ll query(int x, int y) {
        ll res = 0;
        for(int i = x; i; i -= lowbit(i))
            for(int j = y; j; j -= lowbit(j))
                res += bit[i][j];
        return res;
    }
};
BIT a;
```





### 线段树

基础线段树（加法）

```cpp
struct Seg_Tree {
    struct node {
        int l, r;
        ll s;
        
    } seg[N * 4];
    void pushup(int k)
    {

    }
    void set_tag(int k, int l, int r)
    {

    }
    void pushdown(int k)
    {   

    }
    void build(int k, int l, int r) //记得调用
    {
        seg[k] = {l, r};
        if(l == r) {
            seg[k].s = ?;
            seg[k].lazy = ?;
            ?
            return;
        }
        int mid = (l + r) >> 1;
        build(k << 1, l, mid);
        build(k << 1 | 1, mid + 1, r);
        pushup(k);
    }
    void interval_modify(int k, int ql, int qr, ll v) //区间修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
        {
            set_tag(k, ); //更新
            return;
        }
        pushdown(k);
        int mid = (l + r) >> 1;
        if(ql <= mid)
            modify(k << 1, l, mid, v);
        if(mid < qr)
            modify(k << 1 | 1, mid + 1, r, v);
        pushup(k);
    }    
    ll interval_query(int k, int ql, int qr)
    {
        int l = seg[k].l, r = seg[k].r;
        if(ql <= l && r <= qr) //被查询的区间被包含在当前区间内
            return seg[k].s;
        pushdown(k);
        int mid = (l + r) >> 1;
        ll res = 0;
        if(ql <= mid)
            res += query(k << 1, ql, qr), res %= mod;
        if(mid < qr)
            res += query(k << 1 | 1, ql, qr), res %= mod;
        return res;
    }
    void point_modify(int k, int pos, ll v) //单点修改
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
        {
            //
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            point_modify(k << 1, pos, v);
        else
            point_modify(k << 1 | 1, pos, v);
        pushup(k);
    }
    ll point_query(int k, int pos)
    {
        int l = seg[k].l, r = seg[k].r;
        if(l == r && pos == l) 
            return seg[k].s;
        int mid = (l + r) >> 1;
        pushdown(k);
        if(pos <= mid)
            return point_modify(k << 1, pos);
        else
            return point_modify(k << 1 | 1, pos);
        pushup(k);
    }
};
Seg_Tree T1;

int main()
{
    //调用
    T1.build(1, 1, n);  
    T1.interval_modify(1, 2, 4, 5);
}
```

维护和，平方和，立方和（加乘）

```cpp
const int N = 100005;
const int mod = 10007;

int n, m;
struct node {
    int tag_add, tag_mul;
    int sum1, sum2, sum3;
} seg[N * 4];
int a[N];

void update(int k, int len, int add, int mul)
{
    seg[k].tag_mul = seg[k].tag_mul * mul % mod;
    seg[k].tag_add = seg[k].tag_add * mul % mod;
    seg[k].tag_add = ((seg[k].tag_add + add) % mod + mod) % mod;
    if(mul != 1)
    {
        seg[k].sum1 = 1ll * seg[k].sum1 * mul % mod;
        seg[k].sum2 = 1ll * seg[k].sum2 * mul % mod * mul % mod;
        seg[k].sum3 = 1ll * seg[k].sum3 * mul % mod * mul % mod * mul % mod;
    }
    if(add != 0)
    {
        int add2 = add * add % mod, add3 = add2 * add % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum2 % mod * add % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 3ll * seg[k].sum1 % mod * add2 % mod) + mod) % mod;
        seg[k].sum3 = ((seg[k].sum3 + 1ll * len * add3 % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 2ll * seg[k].sum1 % mod * add % mod) + mod) % mod;
        seg[k].sum2 = ((seg[k].sum2 + 1ll * len * add2 % mod) + mod) % mod;
        seg[k].sum1 = ((seg[k].sum1 + 1ll * len * add % mod) + mod) % mod;
    }
}

void pushup(int k)
{
    seg[k].sum1 = (seg[k << 1].sum1 + seg[k << 1 | 1].sum1) % mod;
    seg[k].sum2 = (seg[k << 1].sum2 + seg[k << 1 | 1].sum2) % mod;
    seg[k].sum3 = (seg[k << 1].sum3 + seg[k << 1 | 1].sum3) % mod;
}

void build(int k, int l, int r) //记得调用
{
    seg[k].tag_add = 0;
    seg[k].tag_mul = 1;
    if(l == r) {
        seg[k].sum1 = a[l];
        seg[k].sum2 = seg[k].sum1 * a[l] % mod;
        seg[k].sum3 = seg[k].sum2 * a[l] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    pushup(k);
}

void pushdown(int k, int len)
{
    update(k << 1, (len - (len >> 1)), seg[k].tag_add, seg[k].tag_mul);
    update(k << 1 | 1, len >> 1, seg[k].tag_add, seg[k].tag_mul);
    seg[k].tag_add = 0, seg[k].tag_mul = 1;
}

void modify(int k, int l, int r, int ql, int qr, int add, int mul)
{
    if(ql <= l && r <= qr)
    {
        update(k, r - l + 1, add, mul);
        return;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    if(ql <= mid)
        modify(k << 1, l, mid, ql, qr, add, mul);
    if(mid < qr)
        modify(k << 1 | 1, mid + 1, r, ql, qr, add, mul);
    pushup(k);
}

int query(int k, int l, int r, int ql, int qr, int d)
{
    if(ql <= l && r <= qr)
    {
        if(d == 1)  return seg[k].sum1;
        if(d == 2)  return seg[k].sum2;
        if(d == 3)  return seg[k].sum3;
    }
    pushdown(k, r - l + 1);
    int mid = (l + r) >> 1;
    int res = 0;
    if(ql <= mid)
        res += query(k << 1, l, mid, ql, qr, d), res %= mod;
    if(mid < qr)
        res += query(k << 1 | 1, mid + 1, r, ql, qr, d), res %= mod;
    pushup(k);
    return res;
}

void init()
{
    for(int i = 1; i <= n; i ++)    
        a[i] = 0;
}

int main()
{
    while(scanf("%d%d", &n, &m))
    {
        if(!n && !m)
            break;
        init();
        build(1, 1, n);

        while(m --)
        {
            int op, l, r, v;
            scanf("%d%d%d%d", &op, &l, &r, &v);
            if(op == 1)
                modify(1, 1, n, l, r, v, 1);
            else if(op == 2)
                modify(1, 1, n, l, r, 0, v);
            else if(op == 3)
                modify(1, 1, n, l, r, v, 0);
            else 
                printf("%d\n", query(1, 1, n, l, r, v));
        }
    }
    return 0;
}
```





### Treap

```
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1. 插入数值 x。
2. 删除数值 x (若有多个相同的数，应只删除一个)。
3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4. 查询排名为 x 的数值。
5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。
```

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100005, inf = 0x3f3f3f3f;

struct node {
    int l, r;
    int key, val;
    int cnt, sz;
} tr[N];

int rt, idx = 0;

void pushup(int p)
{
    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;
}

int get_node(int key)
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].sz = 1;
    return idx;
}

void build()
{
    get_node(-inf);
    get_node(inf);
    //添加两个哨兵防止越界
    rt = 1;
    tr[1].r = 2;
    pushup(rt);
}

void rrotate(int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r);
    pushup(p);
}

void lrotate(int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l);
    pushup(p);
}

void insert(int &p, int key)
{
    if(!p)  p = get_node(key);
    else if(tr[p].key == key)   tr[p].cnt ++;
    else if(tr[p].key > key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val > tr[p].val)
            rrotate(p);
    }
    else if(tr[p].key < key)
    {
        insert(tr[p].r, key);
        if(tr[tr[p].r].val > tr[p].val)
            lrotate(p);
    }
    pushup(p);
}

void remove(int &p, int key)
{
    if(!p)  return;
    if(tr[p].key == key) 
    {
        if(tr[p].cnt > 1)
            tr[p].cnt --;
        else if(tr[p].l || tr[p].r) //非叶子
        {
            if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                rrotate(p);
                remove(tr[p].r, key);
            }
            else
            {
                lrotate(p);
                remove(tr[p].l, key);
            }
        }
        else
            p = 0;
    }
    else if(tr[p].key > key)
        remove(tr[p].l, key);
    else 
        remove(tr[p].r, key);
    pushup(p);
}

int query_rank_by_key(int p, int key) //该数值排第几
{
    if(!p)  return 0; //查询无效
    if(tr[p].key == key)
        return tr[tr[p].l].sz + 1;
    else if(tr[p].key > key)
        return query_rank_by_key(tr[p].l, key);
    else
        return tr[tr[p].l].sz + tr[p].cnt + query_rank_by_key(tr[p].r, key);
}

int query_key_by_rank (int p, int rk) //求第rk个数的数值
{
    if(!p)  return inf; //查无此人
    if(tr[tr[p].l].sz >= rk)    
        return query_key_by_rank(tr[p].l, rk);
    else if(tr[tr[p].l].sz + tr[p].cnt >= rk)
        return tr[p].key;
    else 
        return query_key_by_rank(tr[p].r, rk - tr[tr[p].l].sz - tr[p].cnt);
}   

int get_prev(int p, int key) //严格小于key的最大数
{
    if(!p)  return -inf;
    if(tr[p].key >= key)
        return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key) //严格大于key的最小数
{
    if(!p)  return inf;
    if(tr[p].key <= key)   
        return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();
    int n;
    scanf("%d", &n);
    while(n --)
    {
        int opt, x;
        scanf("%d%d", &opt, &x);
        if(opt == 1)
            insert(rt, x);
        else if(opt == 2)
            remove(rt, x);
        else if(opt == 3)
            printf("%d\n", query_rank_by_key(rt, x) - 1); //因为加入了两个哨兵 所以需要微调
        else if(opt == 4)
            printf("%d\n", query_key_by_rank(rt, x + 1)); //因为加入了两个哨兵 所以需要微调
        else if(opt == 5)
            printf("%d\n", get_prev(rt, x));
        else 
            printf("%d\n", get_next(rt, x));
    }
}
```





### Splay

```

```





### 笛卡尔树

```

```





### 主席树

```

```





## <a id="Graph">图论</a>




## <a id="DP">动态规划</a>





## <a id="Numbertheory">数论</a> 







## <a id="game">博弈</a>





## <a id="Other">杂项</a>

